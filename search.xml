<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux find 命令</title>
    <url>/post/Linux-find-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>find命令</strong>用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<span id="more"></span>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>find (选项) (参数)</code></p>
<p>查找目录：find &#x2F;（查找范围） -name ‘查找关键字’ -type d<br>查找文件：find &#x2F;（查找范围） -name 查找关键字 -print</p>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</span><br><span class="line">-anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；</span><br><span class="line">-atime&lt;24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</span><br><span class="line">-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；</span><br><span class="line">-cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span><br><span class="line">-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；</span><br><span class="line">-daystart：从本日开始计算时间；</span><br><span class="line">-depth：从指定目录下最深层的子目录开始查找；</span><br><span class="line">-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；</span><br><span class="line">-<span class="built_in">exec</span>&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；</span><br><span class="line">-<span class="literal">false</span>：将find指令的回传值皆设为False；</span><br><span class="line">-fls&lt;列表文件&gt;：此参数的效果和指定“-<span class="built_in">ls</span>”参数类似，但会把结果保存为指定的列表文件；</span><br><span class="line">-follow：排除符号连接；</span><br><span class="line">-fprint&lt;列表文件&gt;：此参数的效果和指定“-<span class="built_in">print</span>”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">-fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-<span class="built_in">printf</span>”参数类似，但会把结果保存成指定的列表文件；</span><br><span class="line">-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；</span><br><span class="line">-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；</span><br><span class="line">-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；</span><br><span class="line">-<span class="built_in">help</span>或——<span class="built_in">help</span>：在线帮助；</span><br><span class="line">-ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；</span><br><span class="line">-ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；</span><br><span class="line">-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；</span><br><span class="line">-iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；</span><br><span class="line">-<span class="built_in">ls</span>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；</span><br><span class="line">-maxdepth&lt;目录层级&gt;：设置最大目录层级；</span><br><span class="line">-mindepth&lt;目录层级&gt;：设置最小目录层级；</span><br><span class="line">-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</span><br><span class="line">-mount：此参数的效果和指定“-xdev”相同；</span><br><span class="line">-mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</span><br><span class="line">-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</span><br><span class="line">-nogroup：找出不属于本地主机群组识别码的文件或目录；</span><br><span class="line">-noleaf：不去考虑目录至少需拥有两个硬连接存在；</span><br><span class="line">-nouser：找出不属于本地主机用户识别码的文件或目录；</span><br><span class="line">-ok&lt;执行指令&gt;：此参数的效果和指定“-<span class="built_in">exec</span>”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；</span><br><span class="line">-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；</span><br><span class="line">-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；</span><br><span class="line">-<span class="built_in">print</span>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；</span><br><span class="line">-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；</span><br><span class="line">-<span class="built_in">printf</span>&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；</span><br><span class="line">-prune：不寻找字符串作为寻找文件或目录的范本样式;</span><br><span class="line">-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</span><br><span class="line">-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；</span><br><span class="line">-<span class="literal">true</span>：将find指令的回传值皆设为True；</span><br><span class="line">-typ&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；</span><br><span class="line">-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；</span><br><span class="line">-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；</span><br><span class="line">-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；</span><br><span class="line">-version或——version：显示版本信息；</span><br><span class="line">-xdev：将范围局限在先行的文件系统中；</span><br><span class="line">-xtype&lt;文件类型&gt;：此参数的效果和指定“-<span class="built_in">type</span>”参数类似，差别在于它针对符号连接检查。</span><br></pre></td></tr></table></figure>

<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>起始目录：查找文件的起始目录</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="根据文件或者正则表达式进行匹配"><a href="#根据文件或者正则表达式进行匹配" class="headerlink" title="根据文件或者正则表达式进行匹配"></a>根据文件或者正则表达式进行匹配</h2><p>列出当前目录及子目录下所有文件和文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find .</span><br></pre></td></tr></table></figure>

<p>在<code>/home</code>目录下查找以.txt结尾的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<p>同上，但忽略大小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home -iname &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; </span><br></pre></td></tr></table></figure>

<p>匹配文件路径或者文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure>

<p>基于正则表达式匹配文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>

<p>同上，但忽略大小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure>

<h2 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数"></a>否定参数</h2><p>找出&#x2F;home下不是以.txt结尾的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure>

<h2 id="根据文件类型进行搜索"><a href="#根据文件类型进行搜索" class="headerlink" title="根据文件类型进行搜索"></a>根据文件类型进行搜索</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type 类型参数</span><br></pre></td></tr></table></figure>

<p>类型参数列表：</p>
<ul>
<li><strong>f</strong> 普通文件</li>
<li><strong>l</strong> 符号连接</li>
<li><strong>d</strong> 目录</li>
<li><strong>c</strong> 字符设备</li>
<li><strong>b</strong> 块设备</li>
<li><strong>s</strong> 套接字</li>
<li><strong>p</strong> Fifo</li>
</ul>
<h2 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h2><p>向下最大深度限制为3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -maxdepth 3 -type f</span><br></pre></td></tr></table></figure>

<p>搜索出深度距离当前目录至少2个子目录的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -mindepth 2 -type f</span><br></pre></td></tr></table></figure>

<h2 id="根据文件时间戳进行搜索"><a href="#根据文件时间戳进行搜索" class="headerlink" title="根据文件时间戳进行搜索"></a>根据文件时间戳进行搜索</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f 时间戳</span><br></pre></td></tr></table></figure>

<p>UNIX&#x2F;Linux文件系统每个文件都有三种时间戳：</p>
<ul>
<li><strong>访问时间</strong>（-atime&#x2F;天，-amin&#x2F;分钟）：用户最近一次访问时间。</li>
<li><strong>修改时间</strong>（-mtime&#x2F;天，-mmin&#x2F;分钟）：文件最后一次修改时间。</li>
<li><strong>变化时间</strong>（-ctime&#x2F;天，-cmin&#x2F;分钟）：文件数据元（例如权限等）最后一次修改时间。</li>
</ul>
<p>搜索最近七天内被访问过的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -atime -7</span><br></pre></td></tr></table></figure>

<p>搜索恰好在七天前被访问过的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -atime 7</span><br></pre></td></tr></table></figure>

<p>搜索超过七天内被访问过的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -atime +7</span><br></pre></td></tr></table></figure>

<p>搜索访问时间超过10分钟的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -amin +10</span><br></pre></td></tr></table></figure>

<p>找出比<span class="exturl" data-url="aHR0cDovL21hbi5saW51eGRlLm5ldC9maWxl">file<i class="fa fa-external-link-alt"></i></span>.log修改时间更长的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -newer file.log</span><br></pre></td></tr></table></figure>

<h2 id="根据文件大小进行匹配"><a href="#根据文件大小进行匹配" class="headerlink" title="根据文件大小进行匹配"></a>根据文件大小进行匹配</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size 文件大小单元</span><br></pre></td></tr></table></figure>

<p>文件大小单元：</p>
<ul>
<li><strong>b</strong> —— 块（512字节）</li>
<li><strong>c</strong> —— 字节</li>
<li><strong>w</strong> —— 字（2字节）</li>
<li><strong>k</strong> —— 千字节</li>
<li><strong>M</strong> —— 兆字节</li>
<li><strong>G</strong> —— 吉字节</li>
</ul>
<p>搜索大于10KB的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size +10k</span><br></pre></td></tr></table></figure>

<p>搜索小于10KB的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size -10k</span><br></pre></td></tr></table></figure>

<p>搜索等于10KB的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size 10k</span><br></pre></td></tr></table></figure>

<p>搜索当前文件夹下大于1G的占用磁盘空间的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -size +1G -exec du -h &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h2><p>删除当前目录下所有.txt文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -delete</span><br></pre></td></tr></table></figure>

<h2 id="根据文件权限-x2F-所有权进行匹配"><a href="#根据文件权限-x2F-所有权进行匹配" class="headerlink" title="根据文件权限&#x2F;所有权进行匹配"></a>根据文件权限&#x2F;所有权进行匹配</h2><p>当前目录下搜索出权限为777的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -perm 777</span><br></pre></td></tr></table></figure>

<p>找出当前目录下权限不是644的<span class="exturl" data-url="aHR0cDovL21hbi5saW51eGRlLm5ldC9waHA=">php<i class="fa fa-external-link-alt"></i></span>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.php&quot; ! -perm 644</span><br></pre></td></tr></table></figure>

<p>找出当前目录用户tom拥有的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -user tom</span><br></pre></td></tr></table></figure>

<p>找出当前目录用户组sunk拥有的所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -group sunk</span><br></pre></td></tr></table></figure>

<h2 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助<code>-exec</code>选项与其他命令结合使用</h2><p>找出当前目录下所有root的文件，并把所有权更改为用户tom</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find .-type f -user root -exec chown tom &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上例中，**{}** 用于与**-exec**选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</p>
<p>找出自己家目录下所有的.txt文件并删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find $HOME/. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上例中，**-ok<strong>和</strong>-exec**行为一样，不过它会给出提示，是否执行相应的操作。</p>
<p>查找&#x2F;home&#x2F;sftpuser目录下7天之前的.tar文件，并删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /home/sftpuser -mtime +7 -name &quot;*.tar&quot; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt</span><br></pre></td></tr></table></figure>

<p>将30天前的.log文件移动到old目录中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br></pre></td></tr></table></figure>

<p>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-exec ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="搜索但跳出指定的目录"><a href="#搜索但跳出指定的目录" class="headerlink" title="搜索但跳出指定的目录"></a>搜索但跳出指定的目录</h2><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure>

<h2 id="find其他技巧收集"><a href="#find其他技巧收集" class="headerlink" title="find其他技巧收集"></a>find其他技巧收集</h2><p>要列出所有长度为零的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Github</title>
    <url>/post/Github%20+%20Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本blog利用 Hexo + Github 搭建个人博客，内容包含基本工具（Node.js、Git、Github、Hexo）、利用Hexo进行发布、修改、删除文章</p>
<span id="more"></span>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>在开始一切之前，你必须已经：</p>
<ul>
<li>有一个github账号，没有的话去注册一个</li>
<li>安装了node.js、npm</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
<p>本文所使用的环境：</p>
<ul>
<li>Windows11</li>
<li><span class="exturl" data-url="bWFpbHRvOiYjMTEwOyYjMTExOyYjeDY0OyYjMTAxOyYjNDY7JiN4NmE7JiN4NzM7JiM2NDsmIzExODsmIzQ5OyYjeDM2OyYjeDJlOyYjeDMxOyYjNTI7JiM0NjsmIzUwOw==">&#110;&#111;&#x64;&#101;&#46;&#x6a;&#x73;&#64;&#118;&#49;&#x36;&#x2e;&#x31;&#52;&#46;&#50;<i class="fa fa-external-link-alt"></i></span> —— git命令行输入<code>node -v</code></li>
<li><span class="exturl" data-url="bWFpbHRvOiYjMTAzOyYjeDY5OyYjMTE2OyYjNjQ7JiM1MDsmI3gyZTsmI3gzMzsmI3gzMzsmI3gyZTsmIzQ4OyYjNDY7JiN4Nzc7JiN4Njk7JiN4NmU7JiN4NjQ7JiN4NmY7JiMxMTk7JiMxMTU7JiM0NjsmI3gzMjs=">&#103;&#x69;&#116;&#64;&#50;&#x2e;&#x33;&#x33;&#x2e;&#48;&#46;&#x77;&#x69;&#x6e;&#x64;&#x6f;&#119;&#115;&#46;&#x32;<i class="fa fa-external-link-alt"></i></span> —— git命令行输入<code>git version</code></li>
<li><span class="exturl" data-url="bWFpbHRvOiYjeDY4OyYjeDY1OyYjeDc4OyYjeDZmOyYjeDQwOyYjNTQ7JiM0NjsmI3gzMTsmIzQ2OyYjeDMwOw==">&#x68;&#x65;&#x78;&#x6f;&#x40;&#54;&#46;&#x31;&#46;&#x30;<i class="fa fa-external-link-alt"></i></span> —— git命令行输入<code>hexo -v</code>或<code>hexo version</code></li>
<li><span class="exturl" data-url="bWFpbHRvOiYjMTEwOyYjMTAxOyYjeDc4OyYjMTE2OyYjeDQwOyYjNTU7JiM0NjsmI3gzODsmI3gyZTsmI3gzMDs=">&#110;&#101;&#x78;&#116;&#x40;&#55;&#46;&#x38;&#x2e;&#x30;<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ul>
<li>安装Node.js</li>
<li>添加国内镜像源对npm加速</li>
<li>安装Git</li>
<li>注册Github</li>
<li>安装Hexo</li>
<li>连接Github与本地</li>
</ul>
<h1 id="文章基本操作"><a href="#文章基本操作" class="headerlink" title="文章基本操作"></a>文章基本操作</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建文章 </span><br><span class="line">hexo new post &quot;article title&quot; </span><br><span class="line"># 生成静态页面 </span><br><span class="line">hexo g </span><br><span class="line"># 本地预览 </span><br><span class="line">hexo s </span><br><span class="line"># 部署到网站 </span><br><span class="line">hexo d</span><br><span class="line"># 清空缓存并生成新的静态页面 </span><br><span class="line">hexo clean &amp;&amp; hexo g</span><br><span class="line"></span><br><span class="line">修改文章：修改对应文章内容，然后执行命令 </span><br><span class="line">hexo d -g </span><br><span class="line"></span><br><span class="line">删除文章：</span><br><span class="line">删除目录 source\_posts 下对应文章文件，然后执行命令 hexo d -g 即可。</span><br></pre></td></tr></table></figure>

<h1 id="常见配置修改"><a href="#常见配置修改" class="headerlink" title="常见配置修改"></a>常见配置修改</h1><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>在旧版本中的post_wordcount配置似乎已经不可用，因此需要使用symbols_count_time替代</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 卸载原有依赖 不卸载对新插件有影响</span><br><span class="line">npm uninstall hexo-wordcount</span><br><span class="line"># 安装新依赖</span><br><span class="line">npm i hexo-symbols-count-time</span><br><span class="line"></span><br><span class="line">新的配置在symbols_count_time下：配置文件在主题下，themes\next\_config.yml</span><br><span class="line">symbols_count_time:</span><br><span class="line">  # 换行显示字数统计和阅读市场</span><br><span class="line">  separated_meta: true</span><br><span class="line">  # 文章底部显示</span><br><span class="line">  item_text_post: true</span><br><span class="line">  # 博客底部显示 默认为false</span><br><span class="line">  item_text_total: true</span><br></pre></td></tr></table></figure>

<h2 id="隐藏网页底部-powered-By-Hexo-x2F-强力驱动"><a href="#隐藏网页底部-powered-By-Hexo-x2F-强力驱动" class="headerlink" title="隐藏网页底部 powered By Hexo &#x2F; 强力驱动"></a>隐藏网页底部 powered By Hexo &#x2F; 强力驱动</h2><p>打开 themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig，找到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.powered.enable %&#125;</span><br><span class="line">&lt;div class=&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">#&#125;&#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#x27; + nofollow + &#x27; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&#x27;version&#x27;) &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125;</span><br><span class="line">&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">&lt;div class=&quot;theme-info&quot;&gt;&#123;#</span><br><span class="line">#&#125;&#123;&#123; __(&#x27;footer.theme&#x27;) &#125;&#125; – &#123;#</span><br><span class="line">#&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#123;&#123; nofollow &#125;&#125; href=&quot;https://theme-next.org&quot;&gt;&#123;#</span><br><span class="line">#&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">把这段代码首尾分别加上：&lt;!-- 和--&gt;，或者直接删除</span><br></pre></td></tr></table></figure>

<h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><p>next 主题自带<strong>四种样式</strong>。<br>在主题配置文件<code>/next/_config.yml</code>中查找：<code>scheme</code>，找到如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br><span class="line">选择你喜欢的一种样式，去掉前面的 #，其他主题前加上 # 即可</span><br></pre></td></tr></table></figure>

<h2 id="代码块复制选项"><a href="#代码块复制选项" class="headerlink" title="代码块复制选项"></a>代码块复制选项</h2><p>在主题配置文件<code>next/_config.yml</code>中，搜索 codeblock，找到如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  highlight_theme: normal</span><br><span class="line">  copy_button:  # 设置是否开启代码块复制按钮</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true  # 是否显示复制成功信息</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure>

<h2 id="草稿-私密博客"><a href="#草稿-私密博客" class="headerlink" title="草稿 私密博客"></a>草稿 私密博客</h2><blockquote>
<p>草稿相当于很多博客都有的“私密文章”功能。<br>$ hexo new draft “draft”<br>会在source&#x2F;_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。<br>也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。</p>
</blockquote>
<h2 id="目录信息"><a href="#目录信息" class="headerlink" title="目录信息"></a>目录信息</h2><p>在主题配置文件<code>next/_config.yml</code>中，可以是设置展开所有目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Table of Contents in the Sidebar</span><br><span class="line"># Front-matter variable (unsupport wrap expand_all).</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: true</span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br><span class="line">  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span><br><span class="line">  expand_all: true</span><br><span class="line">  # Maximum heading depth of generated toc.</span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure>

<h2 id="提升Hexo-NexT主题加载速度"><a href="#提升Hexo-NexT主题加载速度" class="headerlink" title="提升Hexo NexT主题加载速度"></a>提升Hexo NexT主题加载速度</h2><p>网站加载速度是影响搜索引擎排名的一个重要因素。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLw=="># Google Page Speed Insight<i class="fa fa-external-link-alt"></i></span> 是个很好的网页性能分析工具，可以根据它的分析结果有针对性地对网页进行优化。</p>
<p><strong>优化方案</strong></p>
<p>主要尝试了下面几种方案，按效果排列，把无效的放在了后面。 <strong>关闭动效</strong> 减少动画在Mobile上的优化效果最为明显，是肉眼可见的速度提升。关闭的方法也极为简单，修改NexT的配置文件，<code>next/_config.yml</code>中，将<code>motion</code>的<code>enable</code>置为<code>false</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Use Animate.css to animate everything.</span><br><span class="line"># For more information: https://animate.style</span><br><span class="line">motion:</span><br><span class="line">  enable: false</span><br><span class="line">  async: false</span><br></pre></td></tr></table></figure>

<p>在手机上对比测试了一下，加上这个动画，页面加载确实有明显卡顿。猜想原因是多了一个动画js的render-blocking依赖，手机端的算力也偏弱。</p>
<p>把页脚的icon动效也一并去掉了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the year when the site was setup. If not defined, current year will be used.</span><br><span class="line">  #since: 2021</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https://fontawesome.com/icons</span><br><span class="line">    name: fa fa-heart</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux netstat ss lsof 命令</title>
    <url>/post/Linux-netstat-ss-lsof-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Address already in use</code>这个提示,想必大家遇到过,怎么能快速找到问题并解决呢?下面有几种姿势可以了解一下.在对网络连接或特定于应用程序的问题进行故障排除时，首先要检查的事情之一应该是系统上实际使用了哪些端口，以及哪个应用程序正在侦听特定的端口。本文介绍了如何使用<code>netstat</code>，<code>ss</code>和<code>lsof</code>命令找出哪些服务正在侦听哪些端口。</p>
<span id="more"></span>

<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p><code>netstat</code>是一个命令行工具，可以提供有关网络连接的信息。</p>
<p>要列出所有正在侦听的TCP或UDP端口，包括使用端口的服务和套接字状态，请使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>

<p>此命令中使用的选项具有以下含义：</p>
<ul>
<li><code>-t</code>-显示TCP端口。</li>
<li><code>-u</code> -显示UDP端口。</li>
<li><code>-n</code> -显示数字地址而不是解析主机。</li>
<li><code>-l</code> -仅显示监听端口。</li>
<li><code>-p</code> -显示侦听器进程的PID和名称。</li>
</ul>
<p>输出将如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address   Foreign Address     State       PID/Program name      </span><br><span class="line">tcp        0      0 0:22              0:*               LISTEN      445/sshd              </span><br><span class="line">tcp        0      0 0:25              0:*               LISTEN      929/master            </span><br><span class="line">tcp6       0      0 :::3306           ::*               LISTEN      534/mysqld            </span><br><span class="line">tcp6       0      0 :::80             :::*              LISTEN      515/apache2           </span><br><span class="line">tcp6       0      0 :::22             :::*              LISTEN      445/sshd              </span><br><span class="line">tcp6       0      0 :::25             :::*              LISTEN      929/master            </span><br><span class="line">tcp6       0      0 :::33060          :::*              LISTEN      534/mysqld            </span><br><span class="line">udp        0      0 0:68              0:*                           966/dhclient  </span><br></pre></td></tr></table></figure>

<p>在我们的案例中，重要的几列是：</p>
<ul>
<li><code>Proto</code>-套接字使用的协议。</li>
<li><code>Local Address</code> -进程侦听的IP地址和端口号。</li>
<li><code>PID/Program name</code> -PID和进程名称。</li>
</ul>
<p>如果要过滤结果，请使用 grep命令。例如，要查找在TCP端口3366上侦听的进程，你可以输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[puaiuc@t3 ~]$ netstat -tnlp | grep :3366</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::33660                :::*                    LISTEN      2285/mysqld         </span><br><span class="line">tcp6       0      0 :::33661                :::*                    LISTEN      2285/mysqld         </span><br><span class="line">tcp6       0      0 :::3366                 :::*                    LISTEN      2285/mysqld   </span><br></pre></td></tr></table></figure>

<p>如果输出为空，则表示端口上没有监听。</p>
<p>你也可以根据条件过滤列表，例如PID，协议，状态等。</p>
<p><code>netstat</code>已过时，被<code>ss</code>和 <code>ip</code> 取代，但它仍然是检查网络连接的最常用命令。</p>
<h1 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h1><p>检查监听端口</p>
<p><code>ss</code>是新的<code>netstat</code>。它缺少<code>netstat</code>的某些功能，但是公开了更多的TCP状态，并且速度稍快。命令选项基本相同，因此从<code>netstat</code>到<code>ss</code>的转换并不困难。</p>
<p>要使用<code>ss</code>获取所有监听端口的列表，请输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ss -tunlp</span><br></pre></td></tr></table></figure>

<p>输出与<code>netstat</code>报告的输出几乎相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">State    Recv-Q   Send-Q     Local Address:Port      Peer Address:Port                                                                                          </span><br><span class="line">LISTEN   0        128              0:22             0:*      users:((&quot;sshd&quot;,pid=445,fd=3))                                                          </span><br><span class="line">LISTEN   0        100              0:25             0:*      users:((&quot;master&quot;,pid=929,fd=13))                                                       </span><br><span class="line">LISTEN   0        128                    *:3306                 *:*      users:((&quot;mysqld&quot;,pid=534,fd=30))                                                       </span><br><span class="line">LISTEN   0        128                    *:80                   *:*      users:((&quot;apache2&quot;,pid=765,fd=4),(&quot;apache2&quot;,pid=764,fd=4),(&quot;apache2&quot;,pid=515,fd=4))     </span><br><span class="line">LISTEN   0        128                 [::]:22                [::]:*      users:((&quot;sshd&quot;,pid=445,fd=4))                                                          </span><br><span class="line">LISTEN   0        100                 [::]:25                [::]:*      users:((&quot;master&quot;,pid=929,fd=14))                                                       </span><br><span class="line">LISTEN   0        70                     *:33060                *:*      users:((&quot;mysqld&quot;,pid=534,fd=33))  </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[puaiuc@t3 ~]$ ss -lnpt src :3366</span><br><span class="line">State      Recv-Q Send-Q                                                Local Address:Port                                                               Peer Address:Port              </span><br><span class="line">LISTEN     0      214                                                              :::3366                                                                         :::*                   users:((&quot;mysqld&quot;,pid=2285,fd=27))</span><br><span class="line">[puaiuc@t3 ~]$ ss -anpt src :3366</span><br><span class="line">State      Recv-Q Send-Q                                                Local Address:Port                                                               Peer Address:Port              </span><br><span class="line">LISTEN     0      214                                                              :::3366                                                                         :::*                   users:((&quot;mysqld&quot;,pid=2285,fd=27))</span><br></pre></td></tr></table></figure>

<h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>检查监听端口</p>
<p><code>lsof</code>是功能强大的命令行应用程序，可提供有关进程打开的文件的信息。</p>
<p>在Linux中，所有内容都是文件。你可以将套接字视为写入网络的文件。</p>
<p>要获取具有<code>lsof</code>的所有侦听TCP端口的列表，请输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof -nP -iTCP -sTCP:LISTEN </span><br></pre></td></tr></table></figure>

<p>使用的选项如下:</p>
<ul>
<li><code>-n</code>-不要将端口号转换为端口名称。</li>
<li><code>-p</code> -不解析主机名，显示数字地址。</li>
</ul>
<p><code>-iTCP -sTCP:LISTEN</code> -仅显示TCP状态为LISTEN的网络文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMAND   PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME  </span><br><span class="line">sshd      445     root    3u  IPv4  16434      0t0  TCP *:22 (LISTEN)  </span><br><span class="line">sshd      445     root    4u  IPv6  16445      0t0  TCP *:22 (LISTEN)  </span><br><span class="line">apache2   515     root    4u  IPv6  16590      0t0  TCP *:80 (LISTEN)  </span><br><span class="line">mysqld    534    mysql   30u  IPv6  17636      0t0  TCP *:3306 (LISTEN)  </span><br><span class="line">mysqld    534    mysql   33u  IPv6  19973      0t0  TCP *:33060 (LISTEN)  </span><br><span class="line">apache2   764 www-data    4u  IPv6  16590      0t0  TCP *:80 (LISTEN)  </span><br><span class="line">apache2   765 www-data    4u  IPv6  16590      0t0  TCP *:80 (LISTEN)  </span><br><span class="line">master    929     root   13u  IPv4  19637      0t0  TCP *:25 (LISTEN)  </span><br><span class="line">master    929     root   14u  IPv6  19638      0t0  TCP *:25 (LISTEN)  </span><br></pre></td></tr></table></figure>

<p>大多数输出列名称都是不言自明的:</p>
<ul>
<li><code>COMMAND</code>，<code>PID</code>，<code>USER</code>-运行与端口关联的程序的名称，PID和用户。</li>
<li><code>NAME</code> -端口号。</li>
</ul>
<p>要查找正在侦听特定端口（例如端口<code>3306</code>）的进程，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof -nP -iTCP:3306 -sTCP:LISTEN  </span><br></pre></td></tr></table></figure>

<p>输出显示MySQL服务器使用端口<code>3306</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME  </span><br><span class="line">mysqld  534 mysql   30u  IPv6  17636      0t0  TCP *:3306 (LISTEN)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux top 命令</title>
    <url>/post/Linux-top-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>top</strong>动态查看进程变化，监控 linux 的系统状况，是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于 Windows 的任务管理器。</p>
<span id="more"></span>

<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p><img src="/post/Linux-top-%E5%91%BD%E4%BB%A4/image-20220425152440575.png"></p>
<h2 id="统计信息区"><a href="#统计信息区" class="headerlink" title="统计信息区"></a>统计信息区</h2><p>前五行是系统整体的统计信息。</p>
<p>第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</p>
<p><code>top - 15:22:47 up 637 days,  5:45,  7 users,  load average: 4.16, 4.32, 4.22</code></p>
<blockquote>
<p>15:22:47  当前时间</p>
<p>up 637 days  系统运行时间</p>
<p>5:45</p>
<p>7 user  当前登录用户数</p>
<p>load average: 4.16, 4.32, 4.22  系统负载，即任务队列的平均长度。</p>
<p>三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</p>
</blockquote>
<p>第二、三行为进程和 CPU 的信息。当有多个 CPU 时，这些内容可能会超过两行。内容如下：</p>
<p><code>Tasks: 306 total,   2 running, 304 sleeping,   0 stopped,   0 zombie %Cpu(s):  5.1 us,  2.2 sy,  0.0 ni, 67.3 id, 25.2 wa,  0.0 hi,  0.2 si,  0.1 st</code></p>
<blockquote>
<p>Tasks:</p>
<p>total  进程总数</p>
<p>running  正在运行的进程数</p>
<p>sleeping  睡眠的进程数</p>
<p>stopped  停止的进程数</p>
<p>zombie  僵尸进程数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cpu(s): </span><br><span class="line">us   用户空间占用CPU百分比 </span><br><span class="line">sy   内核空间占用CPU百分比 </span><br><span class="line">ni   用户进程空间内改变过优先级的进程占用CPU百分比 </span><br><span class="line">id   空闲CPU百分比 </span><br><span class="line">wa   等待输入输出的CPU时间百分比 </span><br><span class="line">hi   硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class="line">si   软中断（Software Interrupts）占用CPU的百分比</span><br><span class="line">st   (Steal time) 是当 hypervisor 服务另一个虚拟处理器的时候，虚拟 CPU 等待实际 CPU 的时间的百分比。</span><br></pre></td></tr></table></figure>
<p><code>KiB Mem : 16431256 total,   512096 free,  2374144 used, 13545016 buff/cache</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mem: </span><br><span class="line">total   物理内存总量 </span><br><span class="line">free   空闲内存总量 </span><br><span class="line">used   使用的物理内存总量 </span><br><span class="line">buff/cache   用作内核缓存的内存量</span><br></pre></td></tr></table></figure>
<p><code>KiB Swap:  4063228 total,  2733612 free,  1329616 used. 13387600 avail Mem </code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swap: </span><br><span class="line">total   交换区总量 </span><br><span class="line">free   空闲交换区总量 </span><br><span class="line">used   使用的交换区总量</span><br><span class="line">avail Mem 缓冲的交换区总量</span><br></pre></td></tr></table></figure>

<p>内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小。</p>
<p>相应的内存再次被换出时可不必再对交换区写入。</p>
<h2 id="进程信息区"><a href="#进程信息区" class="headerlink" title="进程信息区"></a>进程信息区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                              </span><br><span class="line">22651 polkitd   20   0 2797836 413508   7324 S   9.0  2.5   2634:26 mysqld                                                                                                               </span><br><span class="line"> 3707 root      20   0  303468  76968    820 S   5.6  0.5  53865:39 snmpd                                                                                                                </span><br><span class="line">23993 1997      20   0 2252716  15708  10780 S   2.7  0.1  94:51.81 zabbix_server                                                                                                        </span><br><span class="line">24031 1997      20   0 2253288  27508  20768 S   1.0  0.2 216:17.00 zabbix_server        </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PID 进程id </span><br><span class="line">PPID 父进程id </span><br><span class="line">RUSER Real user name </span><br><span class="line">d UID 进程所有者的用户id </span><br><span class="line">e USER 进程所有者的用户名 </span><br><span class="line">f GROUP 进程所有者的组名 </span><br><span class="line">g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ? </span><br><span class="line">h PR 优先级 </span><br><span class="line">i NI nice值。负值表示高优先级，正值表示低优先级 </span><br><span class="line">j P 最后使用的CPU，仅在多CPU环境下有意义 </span><br><span class="line">k %CPU 上次更新到现在的CPU时间占用百分比 </span><br><span class="line">l TIME 进程使用的CPU时间总计，单位秒 </span><br><span class="line">m TIME+ 进程使用的CPU时间总计，单位1/100秒 </span><br><span class="line">n %MEM 进程使用的物理内存百分比 </span><br><span class="line">o VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES </span><br><span class="line">p SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。</span><br><span class="line">q RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA </span><br><span class="line">r CODE 可执行代码占用的物理内存大小，单位kb </span><br><span class="line">s DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb </span><br><span class="line">t SHR 共享内存大小，单位kb </span><br><span class="line">u nFLT 页面错误次数 </span><br><span class="line">v nDRT 最后一次写入到现在，被修改过的页面数。</span><br><span class="line">w S 进程状态。</span><br><span class="line">D=不可中断的睡眠状态 </span><br><span class="line">R=运行 </span><br><span class="line">S=睡眠 </span><br><span class="line">T=跟踪/停止 </span><br><span class="line">Z=僵尸进程 </span><br><span class="line">x COMMAND 命令名/命令行 </span><br><span class="line">y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 </span><br><span class="line">z Flags 任务标志，参考 sched.h</span><br></pre></td></tr></table></figure>

<p>默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、% CPU、% MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。</p>
<h2 id="top-命令选项"><a href="#top-命令选项" class="headerlink" title="top 命令选项"></a>top 命令选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top [-] [d] [p] [q] [C] [S] [s] [n] </span><br><span class="line">-d 后跟秒数，指定每两次屏幕信息刷新之间的时间间隔，表示进程界面更新时间（默认为5秒）。如：将top进程表在/tmp/top.txt中打印2次。</span><br><span class="line"> top -b -n 2 &gt; /tmp/top.txt</span><br><span class="line">-p进程ID    如：查看进程号为1的进程。top -p 1</span><br><span class="line">-q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。</span><br><span class="line">-S 指定累计模式 </span><br><span class="line">-s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</span><br><span class="line">-i 使top不显示任何闲置或者僵死进程。</span><br><span class="line">-c 显示整个命令行而不只是显示命令名</span><br></pre></td></tr></table></figure>

<h2 id="Top-命令常见的操作"><a href="#Top-命令常见的操作" class="headerlink" title="Top 命令常见的操作"></a>Top 命令常见的操作</h2><p>1、 2500 毫秒刷新一次 TOP 内容，总共 5 次，输出内容存放到 performace.txt 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -b -d 2.5 -n 5 &gt; performace.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：要将内容输出到文件中，必须使用 - b，表示批处理选项</p>
</blockquote>
<p>2、TOP 命令如何快速按 % CPU、% MEM、TIME + 列排序</p>
<p>a) % CPU：使用大写字母按键：P<br>b) % MEM：使用大写字母按键：M<br>c) T IME + 使用大写字母按键：T</p>
<blockquote>
<p>注：TOP 默认排序为倒序，如果确实需要升序排序，可以使用大写字母按键：R</p>
</blockquote>
<p>3、TOP 命令中显示其它列值、将两列互换等</p>
<p>a) 选择显示列或隐藏列：使用小写字母按键：f<br>c) 交换列显示顺序：使用小写字母按键：o<br>b) 选择需要排序的列：使用大写字母按键：F</p>
<h2 id="CPU-steal-time"><a href="#CPU-steal-time" class="headerlink" title="CPU steal time"></a>CPU steal time</h2><p>如果你想要部署虚拟环境（例如：Amazon EC2），steal time就是你想要关注的性能指标之一。如果这个指标的数值很高，那么说明机器状态非常糟糕。</p>
<p>虚拟机（VM）会与虚拟环境的宿主机上的多个虚拟机实例共享物理资源。其中之一共享的就是CPU时间切片。如果你的VM的物理机虚拟比是1&#x2F;4， 那么它的CPU使用率不会限制于25%的CPU时间切片－它能够使用超过它设置的虚拟比。（有别于内存的使用，内存大小是严格控制的）。</p>
<p>可以使用Linux 的 TOP 命令来看到实时的一些性能指标。</p>
<p>两个你可能较为熟悉的是 %id(空闲 百分比) 和 %wa(I&#x2F;O 等待 百分比)。如果 %id 很低， 那么说明CPU的工作负载很大并且没有多少计算负载能力剩余。如果 %wa 很高，则说明瓶 CPU 处于等待计算的状态，但是正在等待I&#x2F;O活动的完成(类似 从数据库中获取存储在 磁盘上 的一行数据)。</p>
<p>%st（percent steal time） 是CPU展示的最后一个性能指标。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/post/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日常工作中总结，积累的一些常用Linux命令</p>
<span id="more"></span>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/redhat-release								<span class="comment">#查看centos系统的版本</span></span><br><span class="line"><span class="built_in">cat</span> /proc/version									<span class="comment">#查看Linux版本</span></span><br><span class="line"><span class="built_in">uname</span> -a											<span class="comment">#显示系统信息</span></span><br><span class="line"><span class="built_in">uname</span> -n 											<span class="comment">#查看主机名</span></span><br><span class="line"><span class="built_in">uname</span> -r											<span class="comment">#查看Linux内核信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ulimit</span> -a  	 										<span class="comment">#显示当前系统所有的limit资源信息</span></span><br><span class="line"><span class="built_in">ulimit</span> -u    										<span class="comment">#用户最大可用的进程数</span></span><br><span class="line"><span class="built_in">ulimit</span> -n 	 										<span class="comment">#查看进程可以打开的最大文件描述符的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#selinux</span></span><br><span class="line">getenforce                                          <span class="comment">#查看是否开启</span></span><br><span class="line">setenforce 0                                        <span class="comment">#临时关闭</span></span><br><span class="line"></span><br><span class="line">systemctl status firewalld						    <span class="comment">#查看firewall状态</span></span><br><span class="line">systemctl start firewalld.service				    <span class="comment">#启动firewall</span></span><br><span class="line">systemctl stop firewalld.service				    <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service				    <span class="comment">#禁止firewall开机启动</span></span><br><span class="line"></span><br><span class="line">service iptables status   						    <span class="comment">#查看iptables防火墙</span></span><br><span class="line">service iptables stop							    <span class="comment">#关闭iptables防火墙</span></span><br><span class="line">systemctl stop iptables.service                     <span class="comment">#关闭iptables防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> iptables.service                  <span class="comment">#禁止iptables开机启动</span></span><br><span class="line">iptables -L -n								        <span class="comment">#查看当前iptables规则</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">history</span>  											<span class="comment">#查看历史命令</span></span><br><span class="line">netstat -tunlp										<span class="comment">#查看已使用的端口</span></span><br><span class="line">netstat -tunlp | grep 82				 			<span class="comment">#查看某个端口是否被占用</span></span><br><span class="line">netstat -ntpl |grep 3306							<span class="comment">#查询端口被占用的id</span></span><br><span class="line">ss -ntl|grep :1521                                  <span class="comment">#查看某个端口是否被占用</span></span><br><span class="line"><span class="built_in">df</span> -h    											<span class="comment">#查看硬件信息</span></span><br><span class="line"><span class="built_in">du</span> -sh *                                      		<span class="comment">#查看当前目录下各个文件及目录占用空间大小</span></span><br><span class="line">free -h  											<span class="comment">#查看内存</span></span><br><span class="line">ps -ef												<span class="comment">#查看所有的进程信息</span></span><br><span class="line">ps aux												<span class="comment">#查看进程的详细信息	</span></span><br><span class="line"></span><br><span class="line">top</span><br><span class="line">lscpu												<span class="comment">#查看cpu信息</span></span><br><span class="line">sar -d -p 1 20										<span class="comment">#查看磁盘读写</span></span><br><span class="line">iostat -dxk 1 20				          			<span class="comment">#查看磁盘读写</span></span><br><span class="line"></span><br><span class="line">$ lsblk -d -o name,rota                             <span class="comment">#服务器查看硬盘是SSD还是SATA</span></span><br><span class="line">NAME ROTA</span><br><span class="line">vda     1</span><br><span class="line">vdb     1</span><br><span class="line">vdc     1</span><br><span class="line">0说明是SSD硬盘；如果返回结果为1，说明是转动盘HDD类的硬盘，SATA。</span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> <span class="string">&#x27;+%Y%m%d%H%M%S&#x27;</span>   <span class="comment">#打印时间20210425212152</span></span><br><span class="line"></span><br><span class="line">watch -n 1 docker ps      <span class="comment">#每隔一秒刷新一次docker ps</span></span><br><span class="line"></span><br><span class="line">ll | <span class="built_in">wc</span> -l       <span class="comment">#  | wc -l   统计数量</span></span><br><span class="line"><span class="built_in">nl</span> regular_express.txt      <span class="comment">#查看文件并显示行号</span></span><br><span class="line"></span><br><span class="line">passwd root											<span class="comment">#修改root密码</span></span><br><span class="line">groupadd puaiuc                                     <span class="comment">#加属主</span></span><br><span class="line"><span class="built_in">chown</span> -R puaiuc:puaiuc nc4.1.0						<span class="comment">#更改文件属主</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> -r /home/packageA /home/packageB		    	    <span class="comment">#将一个文件夹复制到另一个文件夹下</span></span><br><span class="line"></span><br><span class="line">ssh -p 22022 puaiuc@10.19.88.38            		    <span class="comment">#ssh连接服务器</span></span><br><span class="line">ctrl + D										    <span class="comment">#退出ssh连接</span></span><br><span class="line"></span><br><span class="line">sftp -P 22022 puaiuc@10.1.234.67 				                            <span class="comment">#服务器传文件</span></span><br><span class="line">scp -r -P 22022 puaiuc@10.19.83.59:/home/puaiuc/nc4.1.0/nc .                <span class="comment">#服务器传文件</span></span><br><span class="line">scp -r  nmweihu@10.221.172.58:/ora_data1/images/rc_test .</span><br><span class="line">scp  nmweihu@10.221.172.58:/ora_data1/images/rc_test/nc-ui-portal.zip .</span><br><span class="line">scp  nmweihu@10.221.172.58:/ora_data1/images/nc/nginx.tar .</span><br><span class="line">scp -r -P 22022 puaiuc@10.19.88.71:/home/puaiuc/nc/nc4.1.0 . 				<span class="comment">#传文件夹</span></span><br><span class="line">scp  airc@192.168.51.238:/home/airc/docker-compose/hlsf/rc-env.sh .</span><br><span class="line">scp -P 22022 ./docker-compose.yml  puaiuc@10.19.88.59:/opt/ksq    <span class="comment">#将本机文件传输至目标主机</span></span><br><span class="line"></span><br><span class="line">vi ~/.bash_profile                                  <span class="comment">#修改当前用户环境变量</span></span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install                                <span class="comment">#编译安装</span></span><br><span class="line"></span><br><span class="line">Linux环境下使用yum安装zip和unzip</span><br><span class="line">yum install zip</span><br><span class="line">yum install unzip</span><br><span class="line"></span><br><span class="line">zip test.zip zip.txt							<span class="comment">#压缩文件</span></span><br><span class="line">zip -r soft.zip soft/							<span class="comment">#压缩目录</span></span><br><span class="line">unzip xx.zip   									<span class="comment">#解压zip</span></span><br><span class="line"></span><br><span class="line">tar -cvf xxx.tar xxx							<span class="comment">#打包</span></span><br><span class="line">tar -czvf nc_yml.tar.gz *yml                    <span class="comment">#打包多个文件</span></span><br><span class="line">tar -xvf xxx.tar								<span class="comment">#解包</span></span><br><span class="line">tar -zxvf test.tar.gz -C /test   <span class="comment">#指定需要解压到的目录</span></span><br><span class="line"></span><br><span class="line">tar -zcvf xxx.tar.gz xxx						<span class="comment">#压缩</span></span><br><span class="line">tar -zxvf xxx.tar.gz 							<span class="comment">#解压缩</span></span><br><span class="line">tar -ztvf xxx.tar.gz							<span class="comment">#只查看不解压</span></span><br><span class="line"></span><br><span class="line">jar -xvf hello.jar								<span class="comment"># 解压</span></span><br><span class="line">jar -cvf0m hello.jar ./META-INF/MANIFEST.MF .	<span class="comment"># 压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清理服务器缓存</span></span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line"><span class="comment">#vi快捷指令</span></span><br><span class="line">Ctrl – h ：删除光标左方位置的字符</span><br><span class="line">Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端）</span><br><span class="line">Ctrl – w ：由光标位置开始，往左删除单词。往行首删</span><br><span class="line">Alt – d ：由光标位置开始，往右删除单词。往行尾删</span><br><span class="line">Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。</span><br><span class="line">Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。</span><br><span class="line">Ctrl – y ：粘贴之前删除的内容到光标后。</span><br><span class="line">ctrl – t ：交换光标处和之前两个字符的位置。</span><br><span class="line">Alt + . ：使用上一条命令的最后一个参数。</span><br><span class="line">Ctrl – _ ：回复之前的状态。撤销操作。</span><br><span class="line"></span><br><span class="line">:%s/A/B/g    <span class="comment">#vi 批量替换,把A替换成B</span></span><br><span class="line">:%s/192.168.51.227/192.168.51.206/g</span><br><span class="line">:%s/3306/13306/g</span><br><span class="line">:%s/bind_address=0.0.0.0/bind_address=::/g    				<span class="comment">#vi 批量替换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">head</span> -n 200 filename   		<span class="comment">#查看文本文件头部n行 </span></span><br><span class="line"><span class="built_in">tail</span> -n 200 filename   		<span class="comment">#查看文本文件末尾n行</span></span><br><span class="line"><span class="built_in">wc</span> -l filename				<span class="comment">#查看文本文件行数</span></span><br><span class="line"><span class="built_in">tail</span> -200f kibana.log       </span><br><span class="line"><span class="built_in">head</span> -100 rc-tncm-biz_7206.log    <span class="comment">#显示文件开头前100行的内容</span></span><br><span class="line"></span><br><span class="line">[root@bjrdc5-cmc-nmdep-app05 jre]<span class="comment"># readlink -f $(which java)      #查找java安装路径</span></span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64-debug/bin/java</span><br><span class="line"></span><br><span class="line">[root@bjrdc5-cmc-nmdep-app05 /]<span class="comment"># cd /home/</span></span><br><span class="line">[root@bjrdc5-cmc-nmdep-app05 home]<span class="comment"># du -sh *      #去相应目录下查看内存占用信息</span></span><br><span class="line">12K     centos</span><br><span class="line">33G     puaiuc</span><br><span class="line">104G    sftpuser</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> “content” &gt; 文件名   	 <span class="comment">#向文件中写入内容</span></span><br><span class="line"><span class="built_in">echo</span> “content” &gt;&gt; 文件名  	 <span class="comment">#向文件追加内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> &gt;和<span class="built_in">echo</span> &gt;&gt;的区别</span><br><span class="line">&gt; 输出重定向</span><br><span class="line">&gt;&gt; 输出追加重定向</span><br><span class="line"></span><br><span class="line">&gt; filename（文件名称） 							<span class="comment">#linux清空日志文件内容 比如log日志</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 集群故障处理</title>
    <url>/post/MySQL-%E9%9B%86%E7%BE%A4%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天发现生产环境的MySQL InnoDB Cluster 集群突然宕掉，导致系统不可用</p>
<span id="more"></span>

<h1 id="故障分析"><a href="#故障分析" class="headerlink" title="故障分析"></a>故障分析</h1><p>使用MySQL Shell 链接MySQL Router发现，主节点从原来的173漂到了154，目前两个从节点173和174在集群中显示报错。</p>
<p>登陆173服务器，发现MySQL实例进程已经消失，当重启该实例时发现有报错，启动不成功，发现是由于配置文件<code>my.cnf</code>的权限被修成了777，导致启动失败，将其权限改为默认的644之后启动成功</p>
<h1 id="MySQL集群恢复步骤"><a href="#MySQL集群恢复步骤" class="headerlink" title="MySQL集群恢复步骤"></a>MySQL集群恢复步骤</h1><table>
<thead>
<tr>
<th>数据库</th>
<th>当前状态</th>
</tr>
</thead>
<tbody><tr>
<td>10.29.17.173:3066</td>
<td>故障</td>
</tr>
<tr>
<td>10.29.17.174:3066</td>
<td>故障</td>
</tr>
<tr>
<td>10.29.17.154:3066</td>
<td>正常，主节点</td>
</tr>
</tbody></table>
<h2 id="备份数据库数据"><a href="#备份数据库数据" class="headerlink" title="备份数据库数据"></a>备份数据库数据</h2><p>备份10.29.17.154:3066数据库数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456  --single-transaction --set-gtid-purged=OFF --hex-blob 库名 &gt; 保存路径/库名-备份时间.sql</span><br></pre></td></tr></table></figure>

<h2 id="重新初始化故障节点"><a href="#重新初始化故障节点" class="headerlink" title="重新初始化故障节点"></a>重新初始化故障节点</h2><h3 id="停掉数据库实例"><a href="#停掉数据库实例" class="headerlink" title="停掉数据库实例"></a>停掉数据库实例</h3><h3 id="删除数据库数据data目录下所数据"><a href="#删除数据库数据data目录下所数据" class="headerlink" title="删除数据库数据data目录下所数据"></a>删除数据库数据data目录下所数据</h3><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">mysqld --initialize-insecure  --user=mysqlg1 --basedir=$&#123;MYSQL_HOME&#125; --datadir=$&#123;MYSQL_HOME&#125;/data --log_error=$&#123;MYSQL_HOME&#125;/mysql-error.log</span><br><span class="line"></span><br><span class="line">./mysqld start</span><br><span class="line">./mysql.server start</span><br></pre></td></tr></table></figure>

<h2 id="启动新初始化的数据库"><a href="#启动新初始化的数据库" class="headerlink" title="启动新初始化的数据库"></a>启动新初始化的数据库</h2><p>以root身份登录mysql【初始root密码为空】，设置root密码，并赋权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -A</span><br><span class="line">CREATE USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION; </span><br><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h2 id="进入-MySQL-Shell-，连接当前主节点"><a href="#进入-MySQL-Shell-，连接当前主节点" class="headerlink" title="进入 MySQL-Shell ，连接当前主节点"></a>进入 MySQL-Shell ，连接当前主节点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在10.29.17.173服务器上，用MySQL-Shell连接上集群</span><br><span class="line">mysqlsh        										 #链接mysqlshell</span><br><span class="line">shell.connect(&#x27;root@10.29.17.154:3066&#x27;, &#x27;123456&#x27;);  #连接到154节点</span><br><span class="line">var cluster=dba.getCluster(&#x27;sxmycluster&#x27;);     					 #获取当前集群</span><br><span class="line">cluster.status() 								     #查看节点状态</span><br><span class="line">重新扫描节点，在提示节点丢失删除时，选择yes删除丢失或异常的节点</span><br><span class="line">cluster.rescan()</span><br></pre></td></tr></table></figure>

<h2 id="将从节点加入至集群中"><a href="#将从节点加入至集群中" class="headerlink" title="将从节点加入至集群中"></a>将从节点加入至集群中</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在10.29.17.173服务器上，用MySQL-Shell连接上集群</span><br><span class="line">mysqlsh        										 #链接mysqlshell</span><br><span class="line">shell.connect(&#x27;root@10.29.17.154:3066&#x27;,&#x27;123456&#x27;)   #连接到154节点</span><br><span class="line">var cluster=dba.getCluster()     					 #获取当前集群</span><br><span class="line">cluster.status() 								     #查看节点状态</span><br><span class="line">#（秒，默认60），在恢复操作期间等待事务应用的时间，如果向运行一段时间的集群中新增节点时，建议此时间设置大点，否则如下节点增加集群会报超时错误。</span><br><span class="line">shell.options[&#x27;dba.restartWaitTimeout&#x27;]=7200</span><br><span class="line">#增加173从节点,此时加入集群会从主节点同步数据至从节点</span><br><span class="line">cluster.addInstance(&#x27;root@10.29.17.173:3066&#x27;, &#123;&#x27;localAddress&#x27;: &#x27;10.29.17.173&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;,&#x27;recoveryMethod&#x27;:&#x27;clone&#x27;,&#x27;waitRecovery&#x27;:&#x27;1&#x27;&#125;)</span><br><span class="line">cluster.status();     #查看节点状态</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#在10.29.17.174服务器上，用MySQL-Shell连接上集群</span><br><span class="line">mysqlsh        										 #链接mysqlshell</span><br><span class="line">shell.connect(&#x27;root@10.29.17.154:3066&#x27;,&#x27;123456&#x27;)   #连接到154节点</span><br><span class="line">var cluster=dba.getCluster()     					 #获取当前集群</span><br><span class="line">cluster.status() 								     #查看节点状态</span><br><span class="line">#（秒，默认60），在恢复操作期间等待事务应用的时间，如果向运行一段时间的集群中新增节点时，建议此时间设置大点，否则如下节点增加集群会报超时错误。</span><br><span class="line">shell.options[&#x27;dba.restartWaitTimeout&#x27;]=7200</span><br><span class="line">#增加174从节点,此时加入集群会从主节点同步数据至从节点</span><br><span class="line">cluster.addInstance(&#x27;root@10.29.17.174:3066&#x27;, &#123;&#x27;localAddress&#x27;: &#x27;10.29.17.174&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;,&#x27;recoveryMethod&#x27;:&#x27;clone&#x27;,&#x27;waitRecovery&#x27;:&#x27;1&#x27;&#125;)</span><br><span class="line">cluster.status();     #查看节点状态</span><br></pre></td></tr></table></figure>

<h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><p>链接三个数据库可查看到集群状态</p>
<p><code>mysql -h10.29.17.154 -P3066 -uroot -p123456;</code></p>
<p><code>SELECT * FROM performance_schema.replication_group_members;</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL 故障处理</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB Cluster 部署手册</title>
    <url>/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次部署在IPV6和IPV4双栈网络环境下部署。采用InnoDB Cluster，每台服务器实例都运行MySQL Group Replication。MGR有两种模式，一种是Single-Primary，一种是Multi-Primary，即单主或者多主，本文使用的是Single-Primary模式</p>
<span id="more"></span>

<h1 id="逻辑部署图"><a href="#逻辑部署图" class="headerlink" title="逻辑部署图"></a>逻辑部署图</h1><p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/1637581706651-129d00f6-1a4f-46d8-b0d0-84f3500efc09.jpeg"></p>
<ol>
<li>上面这张图看着比较清楚，通过MySQL Shell可以配置出一个高可用自动进行故障转移的MySQL InnoDB Cluster，在后续运维过程中也可以通过MySQL Shell对集群进行状态监控及管理维护。通过MySQL Router向应用层屏蔽底层集群的细节，以应用层将普通的MySQL协议访问集群。</li>
<li>MySQL Group Replication 是最新GA的同步复制方式，具有以下特点：</li>
</ol>
<ul>
<li><p>支持单主和多主模式</p>
</li>
<li><p>基于Paxos算法，实现数据复制的一致性</p>
</li>
<li><p>插件化设计，支持插件检测，新增节点小于集群当前节点主版本号，拒绝加入集群，大于则加入，但无法作为主节点</p>
</li>
<li><p>没有第三方组件依赖</p>
</li>
<li><p>支持全链路SSL通讯</p>
</li>
<li><p>支持IP白名单</p>
</li>
<li><p>不依赖网络多播</p>
</li>
</ul>
<h1 id="搭建MySQL-InnoDB-Cluster"><a href="#搭建MySQL-InnoDB-Cluster" class="headerlink" title="搭建MySQL InnoDB Cluster"></a>搭建MySQL InnoDB Cluster</h1><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><table>
<thead>
<tr>
<th>主机名</th>
<th>主机名称</th>
<th>操作系统</th>
<th>MySQL版本</th>
</tr>
</thead>
<tbody><tr>
<td>10.19.36.42</td>
<td>t1</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
<td>mysql-8.0.25-linux-glibc2.12-x86_64、mysql-router-8.0.25-linux-glibc2.12-x86_64、mysql-shell-8.0.25-linux-glibc2.12-x86-64bit</td>
</tr>
<tr>
<td>10.19.36.43</td>
<td>t2</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
<td>mysql-8.0.25-linux-glibc2.12-x86_64</td>
</tr>
<tr>
<td>10.19.36.44</td>
<td>t3</td>
<td>CentOS Linux release 7.6.1810 (Core)</td>
<td>mysql-8.0.25-linux-glibc2.12-x86_64</td>
</tr>
</tbody></table>
<h2 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h2><p>默认已具备IPV6网络的环境，此次部署三台服务器为IPV4和IPV6双栈网络，IPV6的子网掩码为fec0::&#x2F;48</p>
<table>
<thead>
<tr>
<th>IPV4</th>
<th>IPV6</th>
<th>Hostname</th>
</tr>
</thead>
<tbody><tr>
<td>10.19.36.42</td>
<td>fec0::a13:242a</td>
<td>t1</td>
</tr>
<tr>
<td>10.19.36.43</td>
<td>fec0::a13:242b</td>
<td>t2</td>
</tr>
<tr>
<td>10.19.36.44</td>
<td>fec0::a13:242c</td>
<td>t3</td>
</tr>
</tbody></table>
<h2 id="配置主机名称映射"><a href="#配置主机名称映射" class="headerlink" title="配置主机名称映射"></a>配置主机名称映射</h2><p>为保证三台虚拟机上可正常通过名称解析到对方的IP，这里将<strong>主机名称映射必做写入三台主机的hosts文件中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF &gt;&gt; /etc/hosts</span><br><span class="line">fec0::a13:242a t1</span><br><span class="line">fec0::a13:242b t2</span><br><span class="line">fec0::a13:242c t3</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>如果不配置此项，后续将节点添加至集群中，会报无法解析IP对应的主机名，从而未配置的主机无法添加至集群中。</p>
<h2 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署"></a>MySQL 部署</h2><p>可以参考上一篇文章<span class="exturl" data-url="aHR0cDovL2xlbW5hLmNjL3Bvc3QvU2hlbGwlRTglODQlOUElRTYlOUMlQUMlRTglODclQUElRTUlOEElQTglRTklODMlQTglRTclQkQlQjIlRTQlQkElOEMlRTglQkYlOUIlRTUlODglQjZNeVNRTCVFNiU5NSVCMCVFNiU4RCVBRSVFNSVCQSU5My8=">Shell脚本自动部署二进制MySQL数据库<i class="fa fa-external-link-alt"></i></span></p>
<p>需要注意的是需要将<strong>my.cnf</strong>文件中做略微修改来适配IPV6环境</p>
<p>1、添加  <strong>bind_address&#x3D; ::</strong>   匹配IPV6和IPV4双栈</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">port=3336</span><br><span class="line">socket=/home/mysqlg1/mysql-8.0.25-linux-glibc2.12-x86_64/mysqld.sock</span><br><span class="line"><span class="comment">#default-character-set=utf8</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment">#匹配双栈</span></span><br><span class="line">bind_address= ::</span><br><span class="line">port= 3336</span><br><span class="line"><span class="comment">#数据库最大连接数</span></span><br><span class="line">max_connections = 3000 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>2、将之前IPV4的地址改成IPV6；打开访问数据库白名单，配置为IPV6的子网掩码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##########################mgr set##############################</span></span><br><span class="line"><span class="comment">#数据库会根据port自动生成，在port后面增加0；不建议随便改</span></span><br><span class="line">mysqlx_port=33660</span><br><span class="line">mysqlx_socket=/home/mysqlg1/mysql-8.0.25-linux-glibc2.12-x86_64/mysqlx.sock</span><br><span class="line">loose-group_replication_group_name=<span class="string">&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;</span></span><br><span class="line">loose-group_replication_start_on_boot=off</span><br><span class="line"><span class="comment">#数据组复制端口，建议在port后面加1；此为IP为本机IP地址</span></span><br><span class="line">loose-group_replication_local_address= <span class="string">&quot;[fec0::a13:242a]:33661&quot;</span></span><br><span class="line"><span class="comment">#复制组的集群信息</span></span><br><span class="line"><span class="comment">#集群中所有数据库节点需要配置（此处无须配置本机的端口）</span></span><br><span class="line">loose-group_replication_group_seeds= <span class="string">&quot;[fec0::a13:242b]:33661,[fec0::a13:242c]:33661&quot;</span></span><br><span class="line">loose-group_replication_bootstrap_group= off</span><br><span class="line"><span class="comment">#访问数据库白名单，配置IPV6的子网掩码</span></span><br><span class="line">loose-group_replication_ip_whitelist=<span class="string">&quot;fec0::/48&quot;</span> </span><br><span class="line">loose-group_replication_single_primary_mode = on</span><br><span class="line">loose-group_replication_transaction_size_limit=1500000000</span><br></pre></td></tr></table></figure>

<h2 id="MySQL-Shell配置集群"><a href="#MySQL-Shell配置集群" class="headerlink" title="MySQL Shell配置集群"></a>MySQL Shell配置集群</h2><p>此处默认您已将三个服务器的MySQL数据库都已搭建完成，MySQL数据库端口为3366，root密码为123456</p>
<p>MYSQL CLUSTER集群通过MYSQL SHELL进行初始化，并创建集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar –vxf mysql-shell-8.0.25-linux-glibc2.12-x86-64bit.tar.gz</span><br><span class="line">cd mysql-shell-8.0.25-linux-glibc2.12-x86-64bit</span><br></pre></td></tr></table></figure>

<h3 id="通过MYSQL-SHELL检查主机状态"><a href="#通过MYSQL-SHELL检查主机状态" class="headerlink" title="通过MYSQL SHELL检查主机状态"></a>通过MYSQL SHELL检查主机状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/mysqlsh --no-password</span><br><span class="line">dba.checkInstanceConfiguration(<span class="string">&#x27;root@t1:3366&#x27;</span>,&#123;<span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;interactive&#x27;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">dba.checkInstanceConfiguration(<span class="string">&#x27;root@t2:3366&#x27;</span>,&#123;<span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;interactive&#x27;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">dba.checkInstanceConfiguration(<span class="string">&#x27;root@t3:3366&#x27;</span>,&#123;<span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;interactive&#x27;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">node: 返回 ok说明实例正常</span><br></pre></td></tr></table></figure>

<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420153656973.png"></p>
<h3 id="创建MYSQL-Cluster名称"><a href="#创建MYSQL-Cluster名称" class="headerlink" title="创建MYSQL Cluster名称"></a>创建MYSQL Cluster名称</h3><p>MYSQL SHELL只需要在任意一塔主机机上进行操作就可以了。</p>
<p>创建MYSQL CLUSTER集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/mysqlsh --no-password</span><br><span class="line">#登录任意一台主机MYSQL服务</span><br><span class="line">shell.connect(&#x27;root@[fec0::a13:242a]:3366&#x27;, &#x27;123456&#x27;)  </span><br><span class="line">dba.createCluster(&#x27;mycluster&#x27;, &#123;&#x27;localAddress&#x27;: &#x27;[fec0::a13:242a]&#x27;&#125;) </span><br><span class="line">#创建集群名称为&#x27;mycluster&#x27;，指定MYSQL的IP地址</span><br></pre></td></tr></table></figure>

<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420153806063.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入&#x27; mycluster &#x27;集群 执行该命令以后才能配置集群</span><br><span class="line">var cluster=dba.getCluster(&#x27;mycluster&#x27;)</span><br><span class="line">#检查集群状态</span><br><span class="line">cluster.status();</span><br></pre></td></tr></table></figure>

<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420153845769.png"></p>
<h3 id="增加slave1节点"><a href="#增加slave1节点" class="headerlink" title="增加slave1节点"></a>增加slave1节点</h3><p>节点加入的时候会导致原来的数据库shutdown，如果没有设置全局环境变量，就需要手动启动下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/mysqlsh --no-password</span><br><span class="line"><span class="comment">#需要连接到主节点进行操作</span></span><br><span class="line">var cluster=dba.getCluster(<span class="string">&#x27;mycluster&#x27;</span>)</span><br><span class="line">shell.connect(<span class="string">&#x27;root@[fec0::a13:242a]:3366&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="comment">#（秒，默认60），在恢复操作期间等待事务应用的时间，如果向运行一段时间的集群中新增节点时，建议此时间设置大点，否则如下节点增加集群会报超时错误。</span></span><br><span class="line">shell.options[<span class="string">&#x27;dba.restartWaitTimeout&#x27;</span>]=7200 </span><br><span class="line">cluster.addInstance(<span class="string">&#x27;root@[fec0::a13:242b]:3366&#x27;</span>, &#123;<span class="string">&#x27;localAddress&#x27;</span>: <span class="string">&#x27;[fec0::a13:242b]&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;recoveryMethod&#x27;</span>:<span class="string">&#x27;clone&#x27;</span>,<span class="string">&#x27;waitRecovery&#x27;</span>:<span class="string">&#x27;1&#x27;</span>&#125;)</span><br><span class="line">cluster.status();</span><br></pre></td></tr></table></figure>

<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420154002968.png"></p>
<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420154018985.png"></p>
<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420154025830.png"></p>
<h3 id="增加slave2节点"><a href="#增加slave2节点" class="headerlink" title="增加slave2节点"></a>增加slave2节点</h3><p>节点加入的时候会导致原来的数据库shutdown，如果没有设置全局环境变量，就需要手动启动下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/mysqlsh --no-password</span><br><span class="line">#需要连接到主节点进行操作</span><br><span class="line">var cluster=dba.getCluster(&#x27;mycluster&#x27;)</span><br><span class="line">shell.connect(&#x27;root@[fec0::a13:242a]:3366&#x27;, &#x27;123456&#x27;)</span><br><span class="line">#（秒，默认60），在恢复操作期间等待事务应用的时间，如果向运行一段时间的集群中新增节点时，建议此时间设置大点，否则如下节点增加集群会报超时错误。</span><br><span class="line">shell.options[&#x27;dba.restartWaitTimeout&#x27;]=7200 </span><br><span class="line">cluster.addInstance(&#x27;root@[fec0::a13:242c]:3366&#x27;, &#123;&#x27;localAddress&#x27;: &#x27;[fec0::a13:242c]&#x27;, &#x27;password&#x27;: &#x27;123456&#x27;,&#x27;recoveryMethod&#x27;:&#x27;clone&#x27;,&#x27;waitRecovery&#x27;:&#x27;1&#x27;&#125;)</span><br><span class="line">cluster.status();</span><br></pre></td></tr></table></figure>

<h3 id="检查集群状态"><a href="#检查集群状态" class="headerlink" title="检查集群状态"></a>检查集群状态</h3><p><code>cluster.status();</code></p>
<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420154253447.png"></p>
<h2 id="MySQL-Router"><a href="#MySQL-Router" class="headerlink" title="MySQL Router"></a>MySQL Router</h2><h3 id="MySQL-Router-说明"><a href="#MySQL-Router-说明" class="headerlink" title="MySQL Router 说明"></a>MySQL Router 说明</h3><p>​        MySQL Router是MySQL官方推出的一个轻量级MySQL中间件是处于应用client和dbserver之间的轻量级代理程序，它能检测，分析和转发查询到后端数据库实例，并把结果返回给client。是mysql-proxy的一个替代品.但是和mysql-proxy有区别。mysqlroute使用了两个端口进行读写分离</p>
<table>
<thead>
<tr>
<th>默认端口号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>6446</td>
<td>默认是读写端口</td>
<td>mode  &#x3D; read-write默认情况下第一台主数据库为写主库，当第一台主数据库DOWN机后，第二台数据库被提升为主库,如果第一台不出问题，第二台是不会被使用的。可以作高可用使用</td>
</tr>
<tr>
<td>6447</td>
<td>默认是读端口</td>
<td>如果设置以后，根据设置的列表进行轮询使用</td>
</tr>
</tbody></table>
<p>​        MySQL Router接受前端应用程序请求后，根据不同的端口来区分读写，把连接读写端口的所有写和查询发往主库，把连接只读端口的查询以轮询方式发往多个从库，从而实现读写分离的目的。读写返回的结果会交给MySQL Router,由MySQL Router返回给客户端的应用程序。<br>​        我理解的是mysql-proxy在使用的时候与连接单台数据库操作一样，而mysql route则是把多台主机的读写集中在一起，进行读写分离，在使用的时候还是需要程序进行改动。</p>
<h3 id="初始化MySQL-Router"><a href="#初始化MySQL-Router" class="headerlink" title="初始化MySQL Router"></a>初始化MySQL Router</h3><p>​        MYSQL router是基于MYSQL服务之上的路由层，用于应用程序来访问数据库，向应用层屏蔽底层集群的细节，可以实现读写分析，我们还可以在三台虚拟机上均部署mysql-router，用于高可用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 以当前集群信息创建mysql-router的配置信息，注意这里密码 123456</span><br><span class="line">$tar –vxf mysql-router-8.0.25-linux-glibc2.12-x86_64.tar</span><br><span class="line">$ cd mysql-router-8.0.25-linux-glibc2.12-x86_64</span><br></pre></td></tr></table></figure>

<p>初始化router的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在当前用户下生产router的启动脚本和配置文件</span><br><span class="line">./bin/mysqlrouter --bootstrap root:123456@[fec0::a13:242a]:3366 --directory=$&#123;MYSQLRT_HOME&#125;/aiclster1 --conf-use-sockets --force --user=$&#123;USER&#125;</span><br><span class="line">注：</span><br><span class="line">如上root为MYSQL MGR数据库的管理员账号，123456为数据库管理员密码。</span><br><span class="line">如上的[fec0::a13:242a]数据库MGR的主节点的IP地址，3366为数据库MGR主节点的服务端口；</span><br><span class="line">如上的aiclster1建议设置为数据库MGR的的集群名称，方便后续应用识别使用；</span><br><span class="line">执行如上命令后，如果能够正常连接到MYSQL MGR的主节点，则会显示如下的信息，至少会在指定目录中生成mysqlrouter.conf文件；否则会提示连接数据库失败；</span><br></pre></td></tr></table></figure>

<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420162628768.png"></p>
<h3 id="修改MySQL-Router配置"><a href="#修改MySQL-Router配置" class="headerlink" title="修改MySQL Router配置"></a>修改MySQL Router配置</h3><p><strong>添加双栈</strong></p>
<p><strong>mysql-router-8.0.25-linux-glibc2.12-x86_64&#x2F;aiclster1&#x2F;mysqlrouter.conf</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">........  </span><br><span class="line">bind_address = ::</span><br><span class="line">........  </span><br><span class="line"># 修改mysqlrouter.conf原文件中bind_address=0.0.0.0为::</span><br><span class="line">即 %s/bind_address=0.0.0.0/bind_address=::/g  </span><br></pre></td></tr></table></figure>

<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420162833513.png"></p>
<h3 id="启动-MySQL-Router"><a href="#启动-MySQL-Router" class="headerlink" title="启动 MySQL Router"></a>启动 MySQL Router</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /home/mysqlg1/mysql-router</span><br><span class="line">$ ./start.sh</span><br><span class="line">检查端口和进程</span><br><span class="line">ps -ef |grep router</span><br></pre></td></tr></table></figure>

<h3 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h3><p>至此整套MySQL InnoDB Cluster就部署好了，我们在其它节点以MySQL协议即可访问该MySQL集群。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -hfec0::a13:242a -P6446 -uroot -p123456</span><br><span class="line">或者</span><br><span class="line">mysql -h10.19.36.42 -P6446 -uroot -p123456</span><br></pre></td></tr></table></figure>

<p><img src="/post/MySQL-InnoDB-Cluster-%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/image-20220420162953966.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL 安装</tag>
        <tag>Shell 脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 进阶</title>
    <url>/post/Nginx-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前介绍了Nginx的部署安装，现在具体介绍一下Nginx用法</p>
<span id="more"></span>

<h1 id="Nginx-概述"><a href="#Nginx-概述" class="headerlink" title="Nginx 概述"></a>Nginx 概述</h1><p>Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 Nginx 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， Nginx 是免费的并可以商业化，配置使用也比较简单。</p>
<h1 id="Nginx-特点"><a href="#Nginx-特点" class="headerlink" title="Nginx 特点"></a>Nginx 特点</h1><blockquote>
<p>高并发、高性能；<br>模块化架构使得它的扩展性非常好；<br>异步非阻塞的事件驱动模型这点和 Node.js 相似；<br>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；<br>热部署、平滑升级；<br>完全开源，生态繁荣。</p>
</blockquote>
<h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><blockquote>
<p>Nginx 的最重要的几个使用场景：</p>
</blockquote>
<blockquote>
<p>静态资源服务，通过本地文件系统提供服务；</p>
</blockquote>
<blockquote>
<p>反向代理服务，延伸出包括缓存、负载均衡等；</p>
</blockquote>
<blockquote>
<p>API 服务， OpenResty。</p>
</blockquote>
<h1 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h1><p>不再赘述，可参考之前文章</p>
<h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p>Nginx 的典型配置示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># main段配置信息</span><br><span class="line">user  nginx;                        # 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">worker_processes  auto;             # Nginx 进程数，一般设置为和 CPU 核数一样</span><br><span class="line">error_log  /var/log/nginx/error.log warn;   # Nginx 的错误日志存放目录</span><br><span class="line">pid        /var/run/nginx.pid;      # Nginx 服务启动时的 pid 存放位置</span><br><span class="line"></span><br><span class="line"># events段配置信息</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;     # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span><br><span class="line">    worker_connections 1024;   # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># http段配置信息</span><br><span class="line"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span><br><span class="line">http &#123; </span><br><span class="line">    # 设置日志模式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;   # Nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile            on;   # 开启高效传输模式</span><br><span class="line">    tcp_nopush          on;   # 减少网络报文段的数量</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;   # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;      # 文件扩展名与类型映射表</span><br><span class="line">    default_type        application/octet-stream;   # 默认文件类型</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;   # 加载子配置项</span><br><span class="line"></span><br><span class="line">    # server段配置信息</span><br><span class="line">    server &#123;</span><br><span class="line">      listen       80;       # 配置监听的端口</span><br><span class="line">      server_name  localhost;    # 配置的域名</span><br><span class="line"></span><br><span class="line">      # location段配置信息</span><br><span class="line">      location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;  # 网站根目录</span><br><span class="line">        index  index.html index.htm;   # 默认首页文件</span><br><span class="line">        deny 172.168.22.11;   # 禁止访问的ip地址，可以为all</span><br><span class="line">        allow 172.168.33.44；# 允许访问的ip地址，可以为all</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      error_page 500 502 503 504 /50x.html;  # 默认50x对应的访问页面</span><br><span class="line">      error_page 400 404 error.html;   # 同上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>main</strong>：全局配置，对全局生效；</li>
<li><strong>events</strong>：配置影响 Nginx 服务器与用户的网络连接；</li>
<li><strong>http</strong>：配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li>
<li><strong>server</strong>：配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块；</li>
<li><strong>location</strong>：用于配置匹配的 uri ；</li>
<li><strong>upstream</strong>：配置后端服务器具体地址，负载均衡配置不可或缺的部分。</li>
</ul>
<p>用一张图清晰的展示它的层级结构：</p>
<p><img src="/post/Nginx-%E8%BF%9B%E9%98%B6/640.jpeg"></p>
<h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><p><strong>user</strong>：指定运行 Nginx 的 woker 子进程的属主和属组，其中组可以不指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user USERNAME [GROUP]</span><br><span class="line">user nginx lion; # 用户是nginx;组是lion</span><br></pre></td></tr></table></figure>

<p><strong>pid</strong>：指定运行 Nginx master 主进程的 pid 文件存放路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pid /opt/nginx/logs/nginx.pid # master主进程的的pid存放在nginx.pid的文件</span><br></pre></td></tr></table></figure>

<p><strong>worker_rlimit_nofile_number</strong>：指定 worker 子进程可以打开的最大文件句柄数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量。</span><br></pre></td></tr></table></figure>

<p><strong>worker_rlimit_core</strong>：指定 worker 子进程异常终止后的 core 文件，用于记录分析问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_rlimit_core 50M; # 存放大小限制</span><br><span class="line">working_directory /opt/nginx/tmp; # 存放目录</span><br></pre></td></tr></table></figure>

<p><strong>worker_processes_number</strong>：指定 Nginx 启动的 worker 子进程数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes 4; # 指定具体子进程数量</span><br><span class="line">worker_processes auto; # 与当前cpu物理核心数一致</span><br></pre></td></tr></table></figure>

<p><strong>worker_cpu_affinity</strong>：将每个 worker 子进程与我们的 cpu 物理核心绑定。</p>
<p><strong>worker_priority</strong>：指定 worker 子进程的 nice 值，以调整运行 Nginx 的优先级，通常设定为负值，以优先调用 Nginx 。</p>
<p>Linux 默认进程的优先级值是120，值越小越优先；nice 定范围为 -20 到 +19 。</p>
<p>[备注] 应用的默认优先级值是120加上 nice 值等于它最终的值，这个值越小，优先级越高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_priority -10;   # 120-10=110，110就是最终的优先级</span><br></pre></td></tr></table></figure>

<p><strong>worker_shutdown_timeout</strong>：指定 worker 子进程优雅退出时的超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_shutdown_timeout 5s;</span><br></pre></td></tr></table></figure>

<p><strong>timer_resolution</strong>：worker 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timer_resolution 100ms;</span><br></pre></td></tr></table></figure>

<p><strong>daemon</strong>：指定 Nginx 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemon off;    # 默认是on，后台运行模式</span><br></pre></td></tr></table></figure>

<h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><p><strong>use</strong>：Nginx 使用何种事件驱动模型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use method; # 不推荐配置它，让nginx自己选择</span><br><span class="line">method 可选值为：select、poll、kqueue、epoll、/dev/poll、eventport</span><br></pre></td></tr></table></figure>

<p><strong>worker_connections</strong>：worker 子进程能够处理的最大并发连接数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_connections 1024 # 每个子进程的最大连接数为1024</span><br></pre></td></tr></table></figure>

<p><strong>accept_mutex</strong>：是否打开负载均衡互斥锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accept_mutex on   # 默认是off关闭的，这里推荐打开</span><br></pre></td></tr></table></figure>

<p><strong>server_name 指令</strong></p>
<p>指定虚拟主机域名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_name name1 name2 name3</span><br><span class="line">示例：</span><br><span class="line">server_name www.nginx.com;</span><br></pre></td></tr></table></figure>

<p>域名匹配的四种写法：</p>
<blockquote>
<p>精确匹配：server_name <span class="exturl" data-url="aHR0cDovL3d3dy5uZ2lueC5jb20v">www.nginx.com<i class="fa fa-external-link-alt"></i></span> ;</p>
</blockquote>
<blockquote>
<p>左侧通配：server_name *.nginx.com ;</p>
</blockquote>
<blockquote>
<p>右侧统配：server_name <span class="exturl" data-url="aHR0cDovL3d3dy5uZ2lueC8=">www.nginx<i class="fa fa-external-link-alt"></i></span>.* ;</p>
</blockquote>
<blockquote>
<p>正则匹配：server_name ~^www.nginx.*$ ;</p>
</blockquote>
<p>匹配优先级：<strong>精确匹配</strong> &gt; <strong>左侧通配符匹配</strong> &gt; <strong>右侧通配符匹配</strong> &gt; <strong>正则表达式匹配</strong>。</p>
<p><strong>root</strong></p>
<p>指定静态资源目录位置，它可以写在 http 、 server 、 location 等配置中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root path</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location /image &#123;</span><br><span class="line">  root /opt/nginx/static;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png</span><br></pre></td></tr></table></figure>

<p>[注意] root 会将定义路径与 URI 叠加， alias 则只取定义路径。</p>
<p><strong>alias</strong></p>
<p>它也是指定静态资源目录位置，它只能写在 location 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /image &#123;</span><br><span class="line">  alias /opt/nginx/static/image/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png</span><br></pre></td></tr></table></figure>

<p>[注意] 使用 alias 末尾一定要添加 &#x2F; ，并且它只能位于 location 中。</p>
<p><strong>location</strong></p>
<p>配置路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>匹配规则：</p>
<blockquote>
<p>&#x3D; 精确匹配；<br>~ 正则匹配，区分大小写；<br><del>* 正则匹配，不区分大小写；<br>^</del> 匹配到即停止搜索；</p>
</blockquote>
<p>匹配优先级：&#x3D; &gt; ^~ &gt;  ~ &gt; ~* &gt; 不带任何字符。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  www.nginx-test.com;</span><br><span class="line"></span><br><span class="line">  # 只有当访问 www.nginx-test.com/match_all/ 时才会匹配到/usr/share/nginx/html/match_all/index.html</span><br><span class="line">  location = /match_all/ &#123;</span><br><span class="line">      root  /usr/share/nginx/html</span><br><span class="line">      index index.html</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 当访问 www.nginx-test.com/1.jpg 等路径时会去 /usr/share/nginx/images/1.jpg 找对应的资源</span><br><span class="line">  location ~ \.(jpeg|jpg|png|svg)$ &#123;</span><br><span class="line">    root /usr/share/nginx/images;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 当访问 www.nginx-test.com/bbs/ 时会匹配上 /usr/share/nginx/html/bbs/index.html</span><br><span class="line">  location ^~ /bbs/ &#123;</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>location 中的反斜线</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /test/ &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不带 &#x2F; 当访问 <span class="exturl" data-url="aHR0cDovL3d3dy5uZ2lueC10ZXN0LmNvbS90ZXN0">www.nginx-test.com/test<i class="fa fa-external-link-alt"></i></span> 时， Nginx 先找是否有 test 目录，如果有则找 test 目录下的 index.html ；如果没有 test 目录， nginx 则会找是否有 test 文件；</li>
<li>带 &#x2F; 当访问 <span class="exturl" data-url="aHR0cDovL3d3dy5uZ2lueC10ZXN0LmNvbS90ZXN0">www.nginx-test.com/test<i class="fa fa-external-link-alt"></i></span> 时， Nginx 先找是否有 test 目录，如果有则找 test 目录下的 index.html ，如果没有它也不会去找是否存在 test 文件。</li>
</ul>
<ol start="2">
<li>return</li>
</ol>
<p>停止处理请求，直接返回响应码或重定向到其他 URL ；执行 return 指令后， location 中后续指令将不会被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">return code [text];</span><br><span class="line">return code URL;</span><br><span class="line">return URL;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">location / &#123;</span><br><span class="line">  return 404; # 直接返回状态码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  return 302 /bbs ; # 返回状态码 + 重定向地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  return https://www.baidu.com ; # 返回重定向地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>rewrite</strong></p>
<p>根据指定正则表达式匹配规则，重写 URL 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：rewrite 正则表达式 要替换的内容 [flag];</span><br><span class="line">上下文：server、location、if</span><br><span class="line">示例：rewirte /images/(.*\.jpg)$ /pic/$1; # $1是前面括号(.*\.jpg)的反向引用</span><br></pre></td></tr></table></figure>

<p>flag 可选值的含义：</p>
<p>last 重写后的 URL 发起新请求，再次进入 server 段，重试 location 的中的匹配；<br>break 直接使用重写后的 URL ，不再匹配其它 location 中语句；<br>redirect 返回 302 临时重定向；<br>permanent 返回 301 永久重定向。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion.club; # 要在本地hosts文件进行配置</span><br><span class="line">  root html;</span><br><span class="line">  location /search &#123;</span><br><span class="line">    rewrite ^/(.*) https://www.baidu.com redirect;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /images &#123;</span><br><span class="line">    rewrite /images/(.*) /pics/$1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /pics &#123;</span><br><span class="line">    rewrite /pics/(.*) /photos/$1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /photos &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照这个配置我们来分析：</p>
<p>当访问 fe.lion.club&#x2F;search 时，会自动帮我们重定向到 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tOy8=">https://www.baidu.com；<i class="fa fa-external-link-alt"></i></span><br>当访问 fe.lion.club&#x2F;images&#x2F;1.jpg 时，第一步重写 URL 为 fe.lion.club&#x2F;pics&#x2F;1.jpg ，找到 pics 的 location ，继续重写 URL 为 fe.lion.club&#x2F;photos&#x2F;1.jpg ，找到 &#x2F;photos 的 location 后，去 html&#x2F;photos 目录下寻找 1.jpg 静态资源。</p>
<p><strong>if 指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：if (condition) &#123;...&#125;</span><br><span class="line">上下文：server、location</span><br><span class="line">示例：</span><br><span class="line">if($http_user_agent ~ Chrome)&#123;</span><br><span class="line">  rewrite /(.*)/browser/$1 break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">condition 判断条件：</span><br><span class="line">$variable 仅为变量时，值为空或以0开头字符串都会被当做 false 处理；</span><br><span class="line">= 或 != 相等或不等；</span><br><span class="line">~ 正则匹配；</span><br><span class="line">! ~ 非正则匹配；</span><br><span class="line">~* 正则匹配，不区分大小写；</span><br><span class="line">-f 或 ! -f 检测文件存在或不存在；</span><br><span class="line">-d 或 ! -d 检测目录存在或不存在；</span><br><span class="line">-e 或 ! -e 检测文件、目录、符号链接等存在或不存在；</span><br><span class="line">-x 或 ! -x 检测文件可以执行或不可执行；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实例：</span><br><span class="line">server &#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  root html;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    if ( $uri = &quot;/images/&quot; )&#123;</span><br><span class="line">      rewrite (.*) /pics/ break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当访问 localhost:8080/images/ 时，会进入 if 判断里面执行 rewrite 命令。</span><br></pre></td></tr></table></figure>

<p><strong>autoindex</strong></p>
<p>用户请求以 &#x2F; 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p>
<p>autoindex.conf 配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name fe.lion-test.club;</span><br><span class="line"></span><br><span class="line">  location /download/ &#123;</span><br><span class="line">    root /opt/source;</span><br><span class="line"></span><br><span class="line">    autoindex on; # 打开 autoindex，，可选参数有 on | off</span><br><span class="line">    autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span><br><span class="line">    autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml</span><br><span class="line">    autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当访问 fe.lion.com/download/ 时，会把服务器 /opt/source/download/ 路径下的文件展示出来，如下图所示：</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Nginx 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， Nginx 将这些数据以变量的形式提供给使用者。</p>
<p>下面列举些项目中常用的变量：</p>
<p><img src="/post/Nginx-%E8%BF%9B%E9%98%B6/640-16510468622993.png"></p>
<p>实例演示 var.conf ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8081;</span><br><span class="line">  server_name var.lion-test.club;</span><br><span class="line">  root /usr/share/nginx/html;</span><br><span class="line">  location / &#123;</span><br><span class="line">    return 200 &quot;</span><br><span class="line">remote_addr: $remote_addr</span><br><span class="line">remote_port: $remote_port</span><br><span class="line">server_addr: $server_addr</span><br><span class="line">server_port: $server_port</span><br><span class="line">server_protocol: $server_protocol</span><br><span class="line">binary_remote_addr: $binary_remote_addr</span><br><span class="line">connection: $connection</span><br><span class="line">uri: $uri</span><br><span class="line">request_uri: $request_uri</span><br><span class="line">scheme: $scheme</span><br><span class="line">request_method: $request_method</span><br><span class="line">request_length: $request_length</span><br><span class="line">args: $args</span><br><span class="line">arg_pid: $arg_pid</span><br><span class="line">is_args: $is_args</span><br><span class="line">query_string: $query_string</span><br><span class="line">host: $host</span><br><span class="line">http_user_agent: $http_user_agent</span><br><span class="line">http_referer: $http_referer</span><br><span class="line">http_via: $http_via</span><br><span class="line">request_time: $request_time</span><br><span class="line">https: $https</span><br><span class="line">request_filename: $request_filename</span><br><span class="line">document_root: $document_root</span><br><span class="line">&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们访问 <span class="exturl" data-url="aHR0cDovL3Zhci5saW9uLXRlc3QuY2x1Yjo4MDgxL3Rlc3Q/cGlkPTEyMTQxNCZhbXA7Y2lkPXNhZGFzZA==">http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd<i class="fa fa-external-link-alt"></i></span> 时，由于 Nginx 中写了 return 方法，因此 chrome 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote_addr: 27.16.220.84</span><br><span class="line">remote_port: 56838</span><br><span class="line">server_addr: 172.17.0.2</span><br><span class="line">server_port: 8081</span><br><span class="line">server_protocol: HTTP/1.1</span><br><span class="line">binary_remote_addr: 茉</span><br><span class="line">connection: 126</span><br><span class="line">uri: /test/</span><br><span class="line">request_uri: /test/?pid=121414&amp;cid=sadasd</span><br><span class="line">scheme: http</span><br><span class="line">request_method: GET</span><br><span class="line">request_length: 518</span><br><span class="line">args: pid=121414&amp;cid=sadasd</span><br><span class="line">arg_pid: 121414</span><br><span class="line">is_args: ?</span><br><span class="line">query_string: pid=121414&amp;cid=sadasd</span><br><span class="line">host: var.lion-test.club</span><br><span class="line">http_user_agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36</span><br><span class="line">http_referer: </span><br><span class="line">http_via: </span><br><span class="line">request_time: 0.000</span><br><span class="line">https: </span><br><span class="line">request_filename: /usr/share/nginx/html/test/</span><br><span class="line">document_root: /usr/share/nginx/html</span><br></pre></td></tr></table></figure>

<h1 id="Nginx-应用核心概念"><a href="#Nginx-应用核心概念" class="headerlink" title="Nginx 应用核心概念"></a>Nginx 应用核心概念</h1><p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>
<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>
<p><img src="/post/Nginx-%E8%BF%9B%E9%98%B6/640-16510469299446.jpeg"></p>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理，意思是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<p>反向代理的优势：</p>
<blockquote>
<p>隐藏真实服务器；<br>负载均衡便于横向扩充后端动态服务；<br>动静分离，提升系统健壮性。</p>
</blockquote>
<p>那么“动静分离”是什么？负载均衡又是什么？</p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是指在 Web 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p>
<p><img src="/post/Nginx-%E8%BF%9B%E9%98%B6/640-16510470167559.jpeg"></p>
<p>一般来说，都需要将动态资源和静态资源分开，由于 Nginx 的高并发和静态资源缓存等特性，经常将静态资源部署在 Nginx 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。Nginx 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 B 口， B 口人少车空….”，这个工作人员的作用就是负载均衡。</p>
<p>Nginx 实现负载均衡的策略：</p>
<ul>
<li><strong>轮询策略</strong>：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户；</li>
<li><strong>最小连接数策略</strong>：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求；</li>
<li><strong>最快响应时间策略</strong>：优先分配给响应时间最短的服务器；</li>
<li><strong>客户端 IP 绑定策略</strong>：来自同一个 IP 的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。</li>
</ul>
<h1 id="Nginx-实战配置"><a href="#Nginx-实战配置" class="headerlink" title="Nginx 实战配置"></a>Nginx 实战配置</h1><p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 Nginx 应用配置中的核心，它们分别是：<strong>upstream</strong> 、<strong>proxy_pass</strong> 。</p>
<h2 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h2><p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p>
<p><img src="/post/Nginx-%E8%BF%9B%E9%98%B6/640-165104713686515.jpeg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：upstream name &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">upstream back_end_server&#123;</span><br><span class="line">  server 192.168.100.33:8081</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 upstream 内可使用的指令：</p>
<ul>
<li>server 定义上游服务器地址；</li>
<li>zone 定义共享内存，用于跨 worker 子进程；</li>
<li>keepalive 对上游服务启用长连接；</li>
<li>keepalive_requests 一个长连接最多请求 HTTP 的个数；</li>
<li>keepalive_timeout 空闲情形下，一个长连接的超时时长；</li>
<li>hash 哈希负载均衡算法；</li>
<li>ip_hash 依据 IP 进行哈希计算的负载均衡算法；</li>
<li>least_conn 最少连接数负载均衡算法；</li>
<li>least_time 最短响应时间负载均衡算法；</li>
<li>random 随机负载均衡算法。</li>
</ul>
<p><strong>server</strong></p>
<p>定义上游服务器地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：server address [parameters]</span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<p>parameters 可选值：</p>
<ul>
<li>weight&#x3D;number 权重值，默认为1；</li>
<li>max_conns&#x3D;number 上游服务器的最大并发连接数；</li>
<li>fail_timeout&#x3D;time 服务器不可用的判定时间；</li>
<li>max_fails&#x3D;numer 服务器不可用的检查次数；</li>
<li>backup 备份服务器，仅当其他服务器都不可用时才会启用；</li>
<li>down 标记服务器长期不可用，离线维护。</li>
</ul>
<p><strong>keepalive</strong></p>
<p>限制每个 worker 子进程与上游服务器空闲长连接的最大数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keepalive connections;</span><br><span class="line">上下文：upstream</span><br><span class="line">示例：keepalive 16;</span><br></pre></td></tr></table></figure>



<p><strong>keepalive_requests</strong></p>
<p>单个长连接可以处理的最多 HTTP 请求个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：keepalive_requests number;</span><br><span class="line"></span><br><span class="line">默认值：keepalive_requests 100;</span><br><span class="line"></span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>



<p><strong>keepalive_timeout</strong></p>
<p>空闲长连接的最长保持时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：keepalive_timeout time;</span><br><span class="line">默认值：keepalive_timeout 60s;</span><br><span class="line">上下文：upstream</span><br></pre></td></tr></table></figure>

<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_pass URL;</span><br><span class="line">上下文：location、if、limit_except</span><br><span class="line">示例：</span><br><span class="line">proxy_pass http://127.0.0.1:8081</span><br><span class="line">proxy_pass http://127.0.0.1:8081/proxy</span><br></pre></td></tr></table></figure>

<p>URL 参数原则：</p>
<ol>
<li>URL 必须以 http 或 https 开头；</li>
<li>URL 中可以携带变量；</li>
<li>URL 中是否带 URI ，会直接影响发往上游请求的 URL。</li>
</ol>
<p>接下来让我们来看看两种常见的 URL 用法：</p>
<ol>
<li>proxy_pass <span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTAwLjMzOjgwODEv">http://192.168.100.33:8081<i class="fa fa-external-link-alt"></i></span></li>
<li>proxy_pass <span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTAwLjMzOjgwODEv">http://192.168.100.33:8081/<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>这两种用法的区别就是带 &#x2F; 和不带 &#x2F; ，在配置代理时它们的区别可大了：</p>
<ul>
<li>不带 &#x2F; 意味着 Nginx 不会修改用户 URL ，而是直接透传给上游的应用服务器；</li>
<li>带 &#x2F; 意味着 Nginx 会修改用户 URL ，修改方法是将 location 后的 URL 从用户 URL 中删除。</li>
</ul>
<p>不带 &#x2F; 的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /bbs/&#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>用户请求 URL ：&#x2F;bbs&#x2F;abc&#x2F;test.html</li>
<li>请求到达 Nginx 的 URL ：&#x2F;bbs&#x2F;abc&#x2F;test.html</li>
<li>请求到达上游应用服务器的 URL ：&#x2F;bbs&#x2F;abc&#x2F;test.html</li>
</ol>
<p>带 &#x2F; 的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /bbs/&#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>用户请求 URL ：&#x2F;bbs&#x2F;abc&#x2F;test.html</li>
<li>请求到达 Nginx 的 URL ：&#x2F;bbs&#x2F;abc&#x2F;test.html</li>
<li>请求到达上游应用服务器的 URL ：&#x2F;abc&#x2F;test.html</li>
</ol>
<p>并没有拼接上 &#x2F;bbs ，这点和 root 与 alias 之间的区别是保持一致的。</p>
<h2 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h2><p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 IP 分别是：121.42.11.34 与 121.5.180.193 。</p>
<p>我们把 121.42.11.34 服务器作为上游服务器，做如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># /etc/nginx/conf.d/proxy.conf</span><br><span class="line">server&#123;</span><br><span class="line">  listen 8080;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location /proxy/ &#123;</span><br><span class="line">    root /usr/share/nginx/html/proxy;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># /usr/share/nginx/html/proxy/index.html</span><br><span class="line">&lt;h1&gt; 121.42.11.34 proxy html &lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启 Nginx 服务器 nginx -s reload 。</p>
<p>把 121.5.180.193 服务器作为代理服务器，做如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/nginx/conf.d/proxy.conf</span><br><span class="line">upstream back_end &#123;</span><br><span class="line">  server 121.42.11.34:8080 weight=2 max_conns=1000 fail_timeout=10s max_fails=3;</span><br><span class="line">  keepalive 32;</span><br><span class="line">  keepalive_requests 80;</span><br><span class="line">  keepalive_timeout 20s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name proxy.lion.club;</span><br><span class="line">  location /proxy &#123;</span><br><span class="line">    proxy_pass http://back_end/proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地机器要访问 proxy.lion.club 域名，因此需要配置本地 hosts ，通过命令：vim &#x2F;etc&#x2F;hosts 进入配置文件，添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">121.5.180.193 proxy.lion.club</span><br></pre></td></tr></table></figure>

<p><img src="/post/Nginx-%E8%BF%9B%E9%98%B6/640-165104747299518.jpeg"></p>
<p>分析：</p>
<ol>
<li>当访问 proxy.lion.club&#x2F;proxy 时通过 upstream 的配置找到 121.42.11.34:8080 ；</li>
<li>因此访问地址变为 <span class="exturl" data-url="aHR0cDovLzEyMS40Mi4xMS4zNDo4MDgwL3Byb3h5">http://121.42.11.34:8080/proxy<i class="fa fa-external-link-alt"></i></span> ；</li>
<li>连接到 121.42.11.34 服务器，找到 8080 端口提供的 server ；</li>
<li>通过 server 找到 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;proxy&#x2F;index.html 资源，最终展示出来。</li>
</ol>
<h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 upstream 指令。</p>
<p>我们把 121.42.11.34 服务器作为上游服务器，做如下配置（ &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;balance.conf ）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen 8020;</span><br><span class="line">  location / &#123;</span><br><span class="line">    return 200 &#x27;return 8020 \n&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8030;</span><br><span class="line">  location / &#123;</span><br><span class="line">    return 200 &#x27;return 8030 \n&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">  listen 8040;</span><br><span class="line">  location / &#123;</span><br><span class="line">    return 200 &#x27;return 8040 \n&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后：</p>
<ol>
<li>nginx -t 检测配置是否正确；</li>
<li>nginx -s reload 重启 Nginx 服务器；</li>
<li>执行 ss -nlt 命令查看端口是否被占用，从而判断 Nginx 服务是否正确启动。</li>
</ol>
<p>把 121.5.180.193 服务器作为代理服务器，做如下配置（ &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;balance.conf ）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location /balance/ &#123;</span><br><span class="line">    proxy_pass http://demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后重启 Nginx 服务器。并且在需要访问的客户端配置好 IP 和域名的映射关系。</p>
<p>在客户端机器执行 curl <span class="exturl" data-url="aHR0cDovL2JhbGFuY2UubGlvbi5jbHViL2JhbGFuY2Uv">http://balance.lion.club/balance/<i class="fa fa-external-link-alt"></i></span> 命令：</p>
<p><img src="/post/Nginx-%E8%BF%9B%E9%98%B6/640-165104776872721.jpeg"></p>
<p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p>
<p>接下来，我们再来了解下 Nginx 的其它分发策略。</p>
<p><strong>hash 算法</strong></p>
<p>通过制定关键字作为 hash key ，基于 hash 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  hash $request_uri;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location /balance/ &#123;</span><br><span class="line">    proxy_pass http://demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hash $request_uri 表示使用 request_uri 变量作为 hash 的 key 值，只要访问的 URI 保持不变，就会一直分发给同一台服务器。</p>
<p><strong>ip_hash</strong></p>
<p>根据客户端的请求 IP 进行判断，只要 IP 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 session 保持的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream demo_server &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location /balance/ &#123;</span><br><span class="line">    proxy_pass http://demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最少连接数算法</strong></p>
<p>各个 worker 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：least_conn;</span><br><span class="line"></span><br><span class="line">上下文：upstream;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">upstream demo_server &#123;</span><br><span class="line">  zone test 10M; # zone可以设置共享内存空间的名字和大小</span><br><span class="line">  least_conn;</span><br><span class="line">  server 121.42.11.34:8020;</span><br><span class="line">  server 121.42.11.34:8030;</span><br><span class="line">  server 121.42.11.34:8040;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name balance.lion.club;</span><br><span class="line">  </span><br><span class="line">  location /balance/ &#123;</span><br><span class="line">    proxy_pass http://demo_server;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a><strong>配置缓存</strong></h2><p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ Nginx ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习 Nginx 中如何设置缓存策略。</p>
<p><strong>proxy_cache</strong></p>
<p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache zone | off ; # zone 是共享内存的名称</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache off;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>



<p><strong>proxy_cache_path</strong></p>
<p>设置缓存文件的存放路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_path path [level=levels] ...可选参数省略，下面会详细列举</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_path off</span><br><span class="line"></span><br><span class="line">上下文：http</span><br><span class="line"></span><br><span class="line">参数含义：</span><br><span class="line">path 缓存文件的存放路径；</span><br><span class="line">level path 的目录层级；</span><br><span class="line">keys_zone 设置共享内存；</span><br><span class="line">inactive 在指定时间内没有被访问，缓存会被清理，默认10分钟。</span><br></pre></td></tr></table></figure>



<p><strong>proxy_cache_key</strong></p>
<p>设置缓存文件的 key 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_key</span><br><span class="line"></span><br><span class="line">默认值：proxy_cache_key $scheme$proxy_host$request_uri;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br></pre></td></tr></table></figure>



<p><strong>proxy_cache_valid</strong></p>
<p>配置什么状态码可以被缓存，以及缓存时长。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_valid [code...] time;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">配置示例：proxy_cache_valid 200 304 2m;; # 说明对于状态为200和304的缓存文件的缓存时间是2分钟</span><br></pre></td></tr></table></figure>



<p><strong>proxy_no_cache</strong></p>
<p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_no_cache string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_no_cache $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure>



<p><strong>proxy_cache_bypass</strong></p>
<p>定义条件，在该条件下将不会从缓存中获取响应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：proxy_cache_bypass string;</span><br><span class="line"></span><br><span class="line">上下文：http、server、location</span><br><span class="line"></span><br><span class="line">示例：proxy_cache_bypass $http_pragma    $http_authorization;</span><br></pre></td></tr></table></figure>



<p><strong>upstream_cache_status 变量</strong></p>
<p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MISS: 未命中缓存</span><br><span class="line">HIT：命中缓存</span><br><span class="line">EXPIRED: 缓存过期</span><br><span class="line">STALE: 命中了陈旧缓存</span><br><span class="line">REVALIDDATED: Nginx验证陈旧缓存依然有效</span><br><span class="line">UPDATING: 内容陈旧，但正在更新</span><br><span class="line">BYPASS: X响应从原始服务器获取</span><br></pre></td></tr></table></figure>

<p><strong>配置实例</strong></p>
<p>我们把 121.42.11.34 服务器作为上游服务器，做如下配置（ &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;cache.conf ）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 1010;</span><br><span class="line">  root /usr/share/nginx/html/1010;</span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 1020;</span><br><span class="line">  root /usr/share/nginx/html/1020;</span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 121.5.180.193 服务器作为代理服务器，做如下配置（ &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;cache.conf ）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_cache_path /etc/nginx/cache_temp levels=2:2 keys_zone=cache_zone:30m max_size=2g inactive=60m use_temp_path=off;</span><br><span class="line"></span><br><span class="line">upstream cache_server&#123;</span><br><span class="line">  server 121.42.11.34:1010;</span><br><span class="line">  server 121.42.11.34:1020;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http://cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存就是这样配置，我们可以在 &#x2F;etc&#x2F;nginx&#x2F;cache_temp 路径下找到相应的缓存文件。</p>
<p>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name cache.lion.club;</span><br><span class="line">  # URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;</span><br><span class="line">  if ($request_uri ~ \.(txt|text)$) &#123;</span><br><span class="line">    set $cache_name &quot;no cache&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span><br><span class="line">    proxy_cache cache_zone; # 设置缓存内存</span><br><span class="line">    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟</span><br><span class="line">    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI</span><br><span class="line">    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端</span><br><span class="line">    proxy_pass http://cache_server; # 代理转发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>在学习如何配置 HTTPS 之前，我们先来简单回顾下 HTTPS 的工作流程是怎么样的？它是如何进行加密保证安全的？</p>
<p><strong>HTTPS 工作流程</strong></p>
<ol>
<li>客户端（浏览器）访问 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">https://www.baidu.com<i class="fa fa-external-link-alt"></i></span> 百度网站；</li>
<li>百度服务器返回 HTTPS 使用的 CA 证书；</li>
<li>浏览器验证 CA 证书是否为合法证书；</li>
<li>验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</li>
<li>发送公钥加密后的随机数给百度服务器；</li>
<li>百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</li>
<li>百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</li>
<li>此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</li>
</ol>
<p>这就是 HTTPS 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p>
<p><strong>配置证书</strong></p>
<p>下载证书的压缩文件，里面有个 Nginx 文件夹，把 xxx.crt 和 xxx.key 文件拷贝到服务器目录，再进行如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2 default_server;   # SSL 访问端口号为 443</span><br><span class="line">  server_name lion.club;         # 填写绑定证书的域名(我这里是随便写的)</span><br><span class="line">  ssl_certificate /etc/nginx/https/lion.club_bundle.crt;   # 证书地址</span><br><span class="line">  ssl_certificate_key /etc/nginx/https/lion.club.key;      # 私钥地址</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span><br><span class="line"> </span><br><span class="line">  location / &#123;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">    index        index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此配置后就能正常访问 HTTPS 版的网站了。</p>
<h2 id="配置跨域-CORS"><a href="#配置跨域-CORS" class="headerlink" title="配置跨域 CORS"></a>配置跨域 CORS</h2><p>先简单回顾下跨域究竟是怎么回事。</p>
<p><strong>跨域的定义</strong></p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p>
<p><strong>同源的定义</strong></p>
<p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下面给出了与 URL <span class="exturl" data-url="aHR0cDovL3N0b3JlLmNvbXBhbnkuY29tL2Rpci9wYWdlLmh0bWw=">http://store.company.com/dir/page.html<i class="fa fa-external-link-alt"></i></span> 的源进行对比的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://store.company.com/dir2/other.html 同源</span><br><span class="line">https://store.company.com/secure.html 不同源，协议不同</span><br><span class="line">http://store.company.com:81/dir/etc.html 不同源，端口不同</span><br><span class="line">http://news.company.com/dir/other.html 不同源，主机不同</span><br></pre></td></tr></table></figure>

<p>不同源会有如下限制：</p>
<ul>
<li>Web 数据层面，同源策略限制了不同源的站点读取当前站点的 Cookie 、 IndexDB 、 LocalStorage 等数据；</li>
<li>DOM 层面，同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作；</li>
<li>网络层面，同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li>
</ul>
<p> <strong>Nginx 解决跨域的原理</strong></p>
<p>例如：</p>
<ul>
<li>前端 server 的域名为：fe.server.com</li>
<li>后端服务的域名为：dev.server.com</li>
</ul>
<p>现在我在 fe.server.com 对 dev.server.com 发起请求一定会出现跨域。</p>
<p>现在我们只需要启动一个 Nginx 服务器，将 server_name 设置为 fe.server.com 然后设置相应的 location 以拦截前端需要跨域的请求，最后将请求代理回 dev.server.com 。如下面的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen        80;</span><br><span class="line">  server_name  fe.server.com;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass dev.server.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以完美绕过浏览器的同源策略：fe.server.com 访问 Nginx 的 fe.server.com 属于同源访问，而 Nginx 对服务端转发的请求不会触发浏览器的同源策略。</p>
<h2 id="配置开启-gzip-压缩"><a href="#配置开启-gzip-压缩" class="headerlink" title="配置开启 gzip 压缩"></a>配置开启 gzip 压缩</h2><p>GZIP 是规定的三种标准 HTTP 压缩格式之一。目前绝大多数的网站都在使用 GZIP 传输 HTML 、CSS 、 JavaScript 等资源文件。</p>
<p>对于文本文件， GZiP 的效果非常明显，开启后传输所需流量大约会降至 1&#x2F;4~1&#x2F;3 。</p>
<p>并不是每个浏览器都支持 gzip 的，如何知道客户端是否支持 gzip 呢，请求头中的 Accept-Encoding 来标识对压缩的支持。</p>
<p>启用 gzip 同时需要客户端和服务端的支持，如果客户端支持 gzip 的解析，那么只要服务端能够返回 gzip 的文件就可以启用 gzip 了,我们可以通过 Nginx 的配置来让服务端支持 gzip 。下面的 respone 中 content-encoding:gzip ，指服务端开启了 gzip 的压缩方式。</p>
<p>在 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F; 文件夹中新建配置文件 gzip.conf ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># # 默认off，是否开启gzip</span><br><span class="line">gzip on; </span><br><span class="line"># 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</span><br><span class="line">gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line"># ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #</span><br><span class="line"></span><br><span class="line"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</span><br><span class="line">gzip_static on;</span><br><span class="line"></span><br><span class="line"># 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</span><br><span class="line">gzip_proxied any;</span><br><span class="line"></span><br><span class="line"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"></span><br><span class="line"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</span><br><span class="line"># gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本；</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx 学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 部署安装</title>
    <url>/post/Nginx-%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍Nginx两种部署方式，二进制安装及docker安装</p>
<span id="more"></span>

<h1 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h1><h2 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h2><p>安装包目录结构</p>
<p><img src="/post/Nginx-%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/image-20220427104134433.png" alt="image-20220427104134433"></p>
<p><strong>nginx_auto_install.sh</strong> 脚本，根据需要修改版本号及安装目录等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">proc_dir=`pwd`;</span><br><span class="line"></span><br><span class="line">#安装包及依赖包名</span><br><span class="line">program_list=&quot;zlib-1.2.11 pcre-8.44 openssl-1.1.1j nginx-1.20.1&quot;;</span><br><span class="line">#安装目录</span><br><span class="line">nginx_install_dir=&quot;/usr/local/nginx&quot;;</span><br><span class="line">nginx_pid=&quot;$&#123;nginx_install_dir&#125;/nginx.pid&quot;;</span><br><span class="line">nginx_tmp_dir=&quot;&quot;;</span><br><span class="line">with_pcre=&quot;&quot;;</span><br><span class="line">with_zlib=&quot;&quot;;</span><br><span class="line">with_openssl=&quot;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for sign_program in `echo &quot;$&#123;program_list&#125;&quot;`</span><br><span class="line">   do</span><br><span class="line"></span><br><span class="line">    zip_file=&quot;$&#123;sign_program&#125;.tar.gz&quot;;</span><br><span class="line">    echo &quot;zip_file = $&#123;zip_file&#125;&quot;;</span><br><span class="line">   </span><br><span class="line">    tar zxvf $&#123;zip_file&#125;</span><br><span class="line"></span><br><span class="line">    name=`echo $&#123;sign_program&#125;|awk -F&quot;-&quot; &#x27;&#123;print $1&#125;&#x27;`;</span><br><span class="line"></span><br><span class="line">    case $name in </span><br><span class="line">       zlib)</span><br><span class="line">         with_zlib=&quot;$&#123;proc_dir&#125;/$&#123;sign_program&#125;&quot;;</span><br><span class="line">         ;;</span><br><span class="line"></span><br><span class="line">       pcre)</span><br><span class="line">         with_pcre=&quot;$&#123;proc_dir&#125;/$&#123;sign_program&#125;&quot; ;</span><br><span class="line">         ;;</span><br><span class="line"></span><br><span class="line">       openssl)</span><br><span class="line">         with_openssl=&quot;$&#123;proc_dir&#125;/$&#123;sign_program&#125;&quot;;</span><br><span class="line">         ;;</span><br><span class="line"></span><br><span class="line">       nginx)</span><br><span class="line">         nginx_tmp_dir=&quot;$&#123;proc_dir&#125;/$&#123;sign_program&#125;&quot;; </span><br><span class="line">         ;;</span><br><span class="line"></span><br><span class="line">       *)</span><br><span class="line">         echo &quot;Nothing to match&quot;;</span><br><span class="line">         ;;</span><br><span class="line">    </span><br><span class="line">    esac</span><br><span class="line"></span><br><span class="line">   done</span><br><span class="line"></span><br><span class="line">echo &quot;nginx_tmp_dir=$nginx_tmp_dir&quot;;</span><br><span class="line">echo &quot;with_zlib=$with_zlib&quot;;</span><br><span class="line">echo &quot;with_pcre=$with_pcre&quot;;</span><br><span class="line">echo &quot;with_openssl=$with_openssl&quot;;</span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;nginx_tmp_dir&#125; == &quot;&quot; ]||[ &quot;$&#123;with_zlib&#125; == &quot;&quot; ] || [ &quot;$&#123;with_pcre&#125; == &quot;&quot; ] || [ &quot;$&#123;with_openssl&#125; == &quot;&quot; ]; then</span><br><span class="line"></span><br><span class="line">   echo &quot;Error : Some parameter not define&quot;;</span><br><span class="line">else</span><br><span class="line">   echo &quot;Start install nginx .............&quot;;</span><br><span class="line">   cd $&#123;nginx_tmp_dir&#125;</span><br><span class="line">   echo &quot;./configure --prefix=$&#123;nginx_install_dir&#125; --pid-path=$&#123;nginx_pid&#125; --with-http_stub_status_module --with-http_ssl_module --with-pcre=$&#123;with_pcre&#125; --with-zlib=$&#123;with_zlib&#125; --with-openssl=$&#123;with_openssl&#125;&quot;;</span><br><span class="line">   echo &quot;&quot;;</span><br><span class="line">   echo &quot;&quot;;</span><br><span class="line">   ./configure --prefix=$&#123;nginx_install_dir&#125; --pid-path=$&#123;nginx_pid&#125; --with-http_stub_status_module --with-http_ssl_module --with-pcre=$&#123;with_pcre&#125; --with-zlib=$&#123;with_zlib&#125; --with-openssl=$&#123;with_openssl&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">install_list=&quot;make make_install&quot;;</span><br><span class="line"></span><br><span class="line">for sign_install in `echo &quot;$&#123;install_list&#125;&quot;`</span><br><span class="line">   do</span><br><span class="line">      sign_install=`echo &quot;$&#123;sign_install&#125;&quot;|sed &#x27;s/_/ /g&#x27;`</span><br><span class="line">      echo -n &quot;Continue execute $&#123;sign_install&#125; ?(y/n)&quot; </span><br><span class="line">      read name</span><br><span class="line">      if [ &quot;$name&quot; == &quot;Y&quot; ]||[ &quot;$name&quot; == &quot;y&quot; ]; then</span><br><span class="line">         echo &quot; Start execute cmd: $sign_install&quot;;</span><br><span class="line">         sleep 5;</span><br><span class="line">         $&#123;sign_install&#125;</span><br><span class="line">         echo &quot;&quot;;</span><br><span class="line">         echo &quot;&quot;;</span><br><span class="line">      fi          </span><br><span class="line">    </span><br><span class="line">   done</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>使用<strong>root用户安装</strong></p>
</li>
<li><p><code>./nginx_auto_install.sh</code> #执行安装脚本，安装过程一直选择y</p>
</li>
<li><p><code>cd /usr/local</code> 安装结束后,进入&#x2F;usr&#x2F;local 目录 </p>
</li>
<li><p><code>chown -R puaiuc:puaiuc nginx</code> #根据需要更改nginx属组，如果用root用户使用nginx则可以跳过此步骤</p>
</li>
<li><p><code>chmod -R 755 nginx</code>  #赋权</p>
</li>
</ol>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p> <code>cd /usr/local/nginx/conf/nginx.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># main段配置信息</span><br><span class="line">user  nginx;                        # 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">worker_processes  auto;             # Nginx 进程数，一般设置为和 CPU 核数一样</span><br><span class="line">error_log  /var/log/nginx/error.log warn;   # Nginx 的错误日志存放目录</span><br><span class="line">pid        /var/run/nginx.pid;      # Nginx 服务启动时的 pid 存放位置</span><br><span class="line"></span><br><span class="line"># events段配置信息</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;     # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span><br><span class="line">    worker_connections 1024;   # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># http段配置信息</span><br><span class="line"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span><br><span class="line">http &#123; </span><br><span class="line">    # 设置日志模式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;   # Nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile            on;   # 开启高效传输模式</span><br><span class="line">    tcp_nopush          on;   # 减少网络报文段的数量</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;   # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;      # 文件扩展名与类型映射表</span><br><span class="line">    default_type        application/octet-stream;   # 默认文件类型</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;   # 加载子配置项</span><br><span class="line"></span><br><span class="line">    # server段配置信息</span><br><span class="line">    server &#123;</span><br><span class="line">      listen       80;       # 配置监听的端口</span><br><span class="line">      server_name  localhost;    # 配置的域名</span><br><span class="line"></span><br><span class="line">      # location段配置信息</span><br><span class="line">      location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;  # 网站根目录</span><br><span class="line">        index  index.html index.htm;   # 默认首页文件</span><br><span class="line">        deny 172.168.22.11;   # 禁止访问的ip地址，可以为all</span><br><span class="line">        allow 172.168.33.44；# 允许访问的ip地址，可以为all</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      error_page 500 502 503 504 /50x.html;  # 默认50x对应的访问页面</span><br><span class="line">      error_page 400 404 error.html;   # 同上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line">./nginx #启动</span><br><span class="line">./nginx t #检查配置</span><br><span class="line">./nginx -s stop #强制停止</span><br><span class="line">./nginx -s reload #重载配置</span><br></pre></td></tr></table></figure>



<h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>使用docker-compose进行部署，以下为Nginx启动文件 nginx.yml，可以根据需要修改容器名称、端口、宿主机挂载路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.2&#x27;</span><br><span class="line">services:</span><br><span class="line">  nc-ui-portal:</span><br><span class="line">    restart: always</span><br><span class="line">    image: nginx:1.20.1</span><br><span class="line">    ports:</span><br><span class="line">      - 6001:6001</span><br><span class="line">    container_name: nc-ui-portal</span><br><span class="line">    networks:</span><br><span class="line">      - nc-network</span><br><span class="line">    volumes:</span><br><span class="line">      - ./nc-ui-portal/nginx.conf:/etc/nginx/nginx.conf</span><br><span class="line">      - ./nc-ui-portal/conf.d:/etc/nginx/conf.d/</span><br><span class="line">      - ./nc-ui-portal/dist:/home/next/dist/</span><br><span class="line">      - ./nc-ui-portal/logs:/var/log/nginx</span><br><span class="line">      #- ./nc-ui-portal/Security:/etc/nginx/certs    #配置证书</span><br><span class="line">networks:</span><br><span class="line">  nc-network:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<p><img src="/post/Nginx-%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/1642573814443-7c3a4795-1d5c-437c-8eae-dd08e0681bba.png"></p>
<p>上图为文件目录结构示例，nginx.conf、default.conf为配置文件，dist为静态文件目录，根据需要自行修改。</p>
<p>一般情况下docker启动时进行配置，只要把配置文件的目录挂载出来就可以，简洁方便，但是nginx却是先加载一个主配置文件nginx.conf，在nginx.conf里再加载conf.d目录下的子配置文件（一般最少一个default.conf文件）。这比单独挂载一个目录麻烦了不少，但只要思路清晰，倒也不难。</p>
<p>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F; 是子配置项存放处，&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 主配置文件会默认把这个文件夹中所有子配置项都引入；</p>
<p><strong>default.conf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 6001;</span><br><span class="line">  server_name 11.13.17.58;</span><br><span class="line">  client_max_body_size 50M;</span><br><span class="line">  #地址改为本机dist路径</span><br><span class="line">  root /usr/local/nginx/dist/;  </span><br><span class="line">            # Add for nc-res service</span><br><span class="line">          location ~* ^/api &#123;</span><br><span class="line">                proxy_pass http://gateway;</span><br><span class="line">                proxy_connect_timeout 120s;</span><br><span class="line">                proxy_send_timeout 120s;</span><br><span class="line">                proxy_read_timeout 120s;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                rewrite ^/api/(.*)$ /$1 break; </span><br><span class="line">             &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>nginx.conf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server_tokens off;</span><br><span class="line">    #gzip  on;</span><br><span class="line">    #负载均衡配置，配置gateway地址</span><br><span class="line">    upstream gateway &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 11.13.17.48:8005 weight=2;</span><br><span class="line">        server 11.13.17.49:8005 weight=4;</span><br><span class="line">        server 11.13.17.50:8005 weight=4;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动命令：</p>
<p><code>docker-compose -f nginx.yml up -d</code></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Shell 脚本</tag>
        <tag>Nginx 安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本自动部署二进制MySQL数据库</title>
    <url>/post/Shell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E4%BA%8C%E8%BF%9B%E5%88%B6MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该Shell脚本为MySQL Cluster集群中自动部署二进制包MySQL数据库，配置参数为集群参数，可修改成单节点配置，脚本还有功能尚未完成，但依旧不影响使用。</p>
<span id="more"></span>

<h1 id="脚本的逻辑"><a href="#脚本的逻辑" class="headerlink" title="脚本的逻辑"></a>脚本的逻辑</h1><ul>
<li>数据库二进制安装</li>
<li>系统环境配置</li>
<li>数据库配置文件my.cnf配置</li>
<li>数据库初始化</li>
<li>安装完成<br>该脚本部署用户为普通用户，且没有重新添加MySQL用户，可选择是否新建使用MySQL用户安装</li>
</ul>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="部署脚本"><a href="#部署脚本" class="headerlink" title="部署脚本"></a>部署脚本</h2><p><strong>使用前需根据情况修改配置参数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#mysql二进制自动安装脚本</span></span><br><span class="line"><span class="comment">#注意：本脚本是用普通用户安装!!!</span></span><br><span class="line"><span class="comment">#1.如果部署MySQL集群时，为保证三台虚拟机上可正常通过名称解析到对方的IP，这里将主机名称映射必做写入三台主机的hosts文件中，需使用|root用户|添加主机名映射，部署单节点的话忽略</span></span><br><span class="line"><span class="comment">#cat &lt;&lt; EOF &gt;&gt; /etc/hosts</span></span><br><span class="line"><span class="comment">#10.19.36.42   t1</span></span><br><span class="line"><span class="comment">#10.19.36.43   t2</span></span><br><span class="line"><span class="comment">#10.19.36.44   t3</span></span><br><span class="line"><span class="comment">#EOF</span></span><br><span class="line"><span class="comment">#2.在Redhat/CentOS7及以上版本操作系统安装，会默认安装mysql数据库，并自带生成/etc/my.cnf文件，为了方便编辑和管理，我们一般会使用|root用户|将/etc/my.cnf更名为/etc/my.cnfbak，mv /etc/my.cnf /etc/my.cnfbak</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装数据库用户</span></span><br><span class="line">USER=kousq</span><br><span class="line"><span class="comment">#MySQL安装包名</span></span><br><span class="line">BIN_PKG=mysql-8.0.25-linux-glibc2.12-x86_64.tar.xz</span><br><span class="line"><span class="comment">#MySQL安装目录，根据情况自行修改</span></span><br><span class="line">BASE_DIR=/data/test</span><br><span class="line"><span class="comment">#安装包的存放目录</span></span><br><span class="line">BIN_PKG_DIR=<span class="variable">$BASE_DIR</span>/<span class="variable">$BIN_PKG</span></span><br><span class="line"><span class="comment">#MySQL解压后路径</span></span><br><span class="line">MYSQL_PATH=<span class="variable">$BASE_DIR</span>/<span class="variable">$&#123;BIN_PKG%.tar*&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########|my.cnf配置参数|##########</span></span><br><span class="line"><span class="comment">#数据库端口</span></span><br><span class="line">MYSQL_PORT=3306</span><br><span class="line"><span class="comment">#数据库会根据port自动生成，在port后面增加0</span></span><br><span class="line">MYSQLX_PORT=33060</span><br><span class="line"><span class="comment">#根据机器进行调整,操作系统内存的70%-80%最佳</span></span><br><span class="line">BUFFER_POOL_SIZE=20G</span><br><span class="line"><span class="comment">#集群中每个节点的ID不允许重复，否则报错，可设置为IP最后一位</span></span><br><span class="line">SERVER_ID=44</span><br><span class="line"><span class="comment">#数据组复制端口，建议在port后面加1；此为IP为本机IP地址</span></span><br><span class="line">GROUP_REPLICATION_LOCAL_ADDRESS=10.19.36.44:33061</span><br><span class="line"><span class="comment">#集群中所有数据库节点需要配置（此处无须配置本机的端口）</span></span><br><span class="line">GROUP_REPLICATION_GROUP_SEEDS=10.19.36.42:33061,10.19.36.43:33061</span><br><span class="line"><span class="comment"># 导入和导出操作专用目录,该目录需要提前先建好</span></span><br><span class="line">SECURE_FILE_PRIV=<span class="variable">$BASE_DIR</span>/dumpdir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">log_output</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[INFO][<span class="subst">$(date +<span class="string">&quot;%F %T&quot;</span>)</span>] <span class="variable">$1</span> 成功!&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[ERROR][<span class="subst">$(date +<span class="string">&quot;%F %T&quot;</span>)</span>] <span class="variable">$1</span> 失败! 已退出安装&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">install_mysql</span></span>() &#123;</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;正在安装<span class="variable">$&#123;BIN_PKG%.tar*&#125;</span>...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 mysql用户、组</span></span><br><span class="line"><span class="comment">#if ! grep -q &#x27;^mysql:&#x27; /etc/passwd ;then</span></span><br><span class="line"><span class="comment">#  useradd  -s /sbin/nologin -d $MYSQL_PATH mysql</span></span><br><span class="line"><span class="comment">#  log_output &quot;创建mysql用户&quot;</span></span><br><span class="line"><span class="comment">#fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压tar包到/usr/local/目录下</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;mysql二进制包正解压到<span class="variable">$&#123;BASE_DIR&#125;</span>目录下&quot;</span></span><br><span class="line">xz -d <span class="variable">$BIN_PKG</span>  &amp;&amp; tar -vxf <span class="variable">$&#123;BIN_PKG%.xz*&#125;</span> -C <span class="variable">$BASE_DIR</span></span><br><span class="line">log_output <span class="string">&quot;mysql二进制包解压&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置mysqld服务的环境变量</span></span><br><span class="line">result=`<span class="built_in">cat</span> ~/.bash_profile | grep mysql`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$result</span>&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">  <span class="comment">#echo &quot;MYSQL_HOME=$MYSQL_PATH/bin:$PATH&quot; &gt;&gt; ~/.bash_profile &amp;&amp; source ~/.bash_profile</span></span><br><span class="line">  sed -i <span class="string">&quot;/^PATH/i export MYSQL_HOME=&#x27;<span class="variable">$MYSQL_PATH</span>&#x27;&quot;</span> -i ~/.bash_profile</span><br><span class="line">  sed -i <span class="string">&#x27;/^PATH/ s/$/:$&#123;MYSQL_HOME&#125;\/bin/&#x27;</span> ~/.bash_profile</span><br><span class="line">  <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line">  log_output <span class="string">&quot;配置mysqld服务的环境变量&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;检测到mysqld服务的环境变量已配置好&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在部署用户目录下创建配置文件 ~/.my.cnf</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ~/.my.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[client]</span></span><br><span class="line"><span class="string">port=$&#123;MYSQL_PORT&#125;</span></span><br><span class="line"><span class="string">socket=$&#123;MYSQL_PATH&#125;/mysqld.sock</span></span><br><span class="line"><span class="string">default-character-set=utf8mb4</span></span><br><span class="line"><span class="string">[mysqld]</span></span><br><span class="line"><span class="string">port= $&#123;MYSQL_PORT&#125;</span></span><br><span class="line"><span class="string">#数据库最大连接数</span></span><br><span class="line"><span class="string">max_connections = 3000 </span></span><br><span class="line"><span class="string">max_connect_errors = 300</span></span><br><span class="line"><span class="string">datadir=$&#123;MYSQL_PATH&#125;/data</span></span><br><span class="line"><span class="string">socket=$&#123;MYSQL_PATH&#125;/mysqld.sock</span></span><br><span class="line"><span class="string">basedir=$&#123;MYSQL_PATH&#125;</span></span><br><span class="line"><span class="string">log-error=$&#123;MYSQL_PATH&#125;/mysqld.log</span></span><br><span class="line"><span class="string">pid-file=$&#123;MYSQL_PATH&#125;/mysqld.pid</span></span><br><span class="line"><span class="string">default-time-zone = &#x27;+08:00&#x27;</span></span><br><span class="line"><span class="string">lower_case_table_names = 1                                # 忽略大小写</span></span><br><span class="line"><span class="string">enforce_gtid_consistency = ON</span></span><br><span class="line"><span class="string">gtid_mode = ON</span></span><br><span class="line"><span class="string">binlog_checksum  = none</span></span><br><span class="line"><span class="string">default_authentication_plugin = mysql_native_password</span></span><br><span class="line"><span class="string">skip-name-resolve = ON</span></span><br><span class="line"><span class="string"># open_files_limit does not take effect</span></span><br><span class="line"><span class="string">open_files_limit = 65535                                  # 可用的文件描述符数</span></span><br><span class="line"><span class="string">table_open_cache = 2000</span></span><br><span class="line"><span class="string">#For safe write dir</span></span><br><span class="line"><span class="string">local_infile = 0</span></span><br><span class="line"><span class="string">#导入和导出操作专用目录,该目录需要提前先建好</span></span><br><span class="line"><span class="string">secure_file_priv = $&#123;SECURE_FILE_PRIV&#125;</span></span><br><span class="line"><span class="string">#################innodb########################</span></span><br><span class="line"><span class="string">innodb_data_home_dir = $&#123;MYSQL_PATH&#125;/data</span></span><br><span class="line"><span class="string">innodb_data_file_path = ibdata1:512M;ibdata2:512M:autoextend</span></span><br><span class="line"><span class="string">#根据机器进行调整,操作系统内存的70%-80%最佳</span></span><br><span class="line"><span class="string">innodb_buffer_pool_size = $&#123;BUFFER_POOL_SIZE&#125;</span></span><br><span class="line"><span class="string">innodb_flush_log_at_trx_commit = 2</span></span><br><span class="line"><span class="string">innodb_io_capacity = 2500</span></span><br><span class="line"><span class="string">innodb_lock_wait_timeout = 120</span></span><br><span class="line"><span class="string">innodb_log_buffer_size = 1G</span></span><br><span class="line"><span class="string">innodb_log_file_size = 2G</span></span><br><span class="line"><span class="string">innodb_log_files_in_group = 3</span></span><br><span class="line"><span class="string">innodb_max_dirty_pages_pct = 75</span></span><br><span class="line"><span class="string">innodb_read_io_threads = 6</span></span><br><span class="line"><span class="string">innodb_write_io_threads = 6</span></span><br><span class="line"><span class="string">innodb_thread_concurrency = 18</span></span><br><span class="line"><span class="string">innodb_file_per_table = 1</span></span><br><span class="line"><span class="string">innodb_flush_neighbors=1</span></span><br><span class="line"><span class="string">innodb_rollback_on_timeout</span></span><br><span class="line"><span class="string">innodb_undo_directory = $&#123;MYSQL_PATH&#125;/data                    # 重做日志文件的目录路径（最好是 SSD 盘）</span></span><br><span class="line"><span class="string">innodb_log_group_home_dir = $&#123;MYSQL_PATH&#125;/data</span></span><br><span class="line"><span class="string">###################session###########################</span></span><br><span class="line"><span class="string">join_buffer_size = 8M</span></span><br><span class="line"><span class="string">key_buffer_size = 256M                                        # MyISAM 索引块的缓冲区大小</span></span><br><span class="line"><span class="string">bulk_insert_buffer_size = 32M</span></span><br><span class="line"><span class="string">max_heap_table_size = 1G</span></span><br><span class="line"><span class="string">tmp_table_size = 1G</span></span><br><span class="line"><span class="string">read_buffer_size = 32M</span></span><br><span class="line"><span class="string">sort_buffer_size = 32M</span></span><br><span class="line"><span class="string">max_allowed_packet = 1G</span></span><br><span class="line"><span class="string">read_rnd_buffer_size = 32M</span></span><br><span class="line"><span class="string">############log set###################</span></span><br><span class="line"><span class="string">#集群中每个节点的ID不允许重复，否则报错</span></span><br><span class="line"><span class="string">server_id = $&#123;SERVER_ID&#125;</span></span><br><span class="line"><span class="string">log-error = mysqld.err</span></span><br><span class="line"><span class="string">log-bin = binlog</span></span><br><span class="line"><span class="string">log_bin_index = binlog.index</span></span><br><span class="line"><span class="string">max_binlog_size = 2G</span></span><br><span class="line"><span class="string">slow_query_log_file = $&#123;MYSQL_PATH&#125;/slow.log</span></span><br><span class="line"><span class="string">slow_query_log = 1</span></span><br><span class="line"><span class="string">long_query_time = 10</span></span><br><span class="line"><span class="string">log_queries_not_using_indexes = ON</span></span><br><span class="line"><span class="string">log_throttle_queries_not_using_indexes = 10</span></span><br><span class="line"><span class="string">log_slow_admin_statements = ON</span></span><br><span class="line"><span class="string">log_output = FILE,TABLE</span></span><br><span class="line"><span class="string">#master_info_file = $&#123;MYSQL_PATH&#125;/master.info</span></span><br><span class="line"><span class="string">master_info_repository=TABLE</span></span><br><span class="line"><span class="string">log_slave_updates=ON</span></span><br><span class="line"><span class="string">binlog_format=ROW</span></span><br><span class="line"><span class="string">binlog_rows_query_log_events=ON</span></span><br><span class="line"><span class="string">wait_timeout=28800                            # 服务器在关闭非交互式连接之前等待活动的秒数(默认8小时)</span></span><br><span class="line"><span class="string">slave_parallel_workers=48</span></span><br><span class="line"><span class="string">slave_parallel_type=LOGICAL_CLOCK</span></span><br><span class="line"><span class="string">slave_pending_jobs_size_max=1G</span></span><br><span class="line"><span class="string">slave_preserve_commit_order=ON</span></span><br><span class="line"><span class="string"># add new 20210706</span></span><br><span class="line"><span class="string">slave_compressed_protocol=ON</span></span><br><span class="line"><span class="string">transaction_isolation=&#x27;read-committed&#x27;</span></span><br><span class="line"><span class="string">innodb_buffer_pool_instances=64</span></span><br><span class="line"><span class="string">relay_log_info_repository=TABLE</span></span><br><span class="line"><span class="string">##########################mgr set##############################</span></span><br><span class="line"><span class="string">#数据库会根据port自动生成，在port后面增加0；不建议随便改</span></span><br><span class="line"><span class="string">mysqlx_port=$&#123;MYSQLX_PORT&#125;</span></span><br><span class="line"><span class="string">mysqlx_socket=$&#123;MYSQL_PATH&#125;/mysqlx.sock</span></span><br><span class="line"><span class="string">loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;</span></span><br><span class="line"><span class="string">loose-group_replication_start_on_boot=off</span></span><br><span class="line"><span class="string">#数据组复制端口，建议在port后面加1；此为IP为本机IP地址</span></span><br><span class="line"><span class="string">loose-group_replication_local_address= &quot;$&#123;GROUP_REPLICATION_LOCAL_ADDRESS&#125;&quot;</span></span><br><span class="line"><span class="string">#复制组的集群信息</span></span><br><span class="line"><span class="string">#集群中所有数据库节点需要配置（此处无须配置本机的端口）</span></span><br><span class="line"><span class="string">loose-group_replication_group_seeds= &quot;$&#123;GROUP_REPLICATION_GROUP_SEEDS&#125;&quot;</span></span><br><span class="line"><span class="string">loose-group_replication_bootstrap_group= off</span></span><br><span class="line"><span class="string">#loose-group_replication_ip_whitelist=&quot;10.12.0.0/16&quot; #访问数据库白名单</span></span><br><span class="line"><span class="string">loose-group_replication_single_primary_mode = on</span></span><br><span class="line"><span class="string">loose-group_replication_transaction_size_limit=1500000000</span></span><br><span class="line"><span class="string"># 组复制节点权重，权重越大，则主节点数据库异常就由集群中权重大接管主节点,建议是70-100</span></span><br><span class="line"><span class="string">loose-group_replication_member_weight=100 </span></span><br><span class="line"><span class="string">transaction_write_set_extraction = XXHASH64</span></span><br><span class="line"><span class="string">binlog_transaction_dependency_tracking  = WRITESET</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#MySQL导入和导出操作专用目录</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$BASE_DIR</span>/dumpdir  &amp;&amp; <span class="built_in">chmod</span> 755 <span class="variable">$BASE_DIR</span>/dumpdir</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改数据库管理程序的参数</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line">sed -e <span class="string">&#x27;s/^basedir=/basedir=$&#123;MYSQL_HOME&#125;/g&#x27;</span> -e <span class="string">&#x27;s+^datadir=+datadir=$&#123;MYSQL_HOME&#125;/data+g&#x27;</span> -i <span class="variable">$&#123;MYSQL_HOME&#125;</span>/support-files/mysql.server</span><br><span class="line"></span><br><span class="line"><span class="comment">#mysqld服务初始化，设置默认密码为空则将--initialize选项替换为--initialize-insecure选项</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line">mysqld --initialize-insecure  --user=<span class="variable">$&#123;USER&#125;</span> --basedir=<span class="variable">$&#123;MYSQL_HOME&#125;</span> --datadir=<span class="variable">$&#123;MYSQL_HOME&#125;</span>/data --log_error=<span class="variable">$&#123;MYSQL_HOME&#125;</span>/mysql-error.log</span><br><span class="line">log_output <span class="string">&quot;mysql初始化完成(密码为空)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动mysqld服务</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile &amp;&amp; <span class="built_in">cd</span> <span class="variable">$&#123;MYSQL_HOME&#125;</span>/bin &amp;&amp; ./mysqld start </span><br><span class="line"></span><br><span class="line"><span class="comment">#启动mysql程序</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile &amp;&amp; <span class="built_in">cd</span> <span class="variable">$&#123;MYSQL_HOME&#125;</span>/support-files &amp;&amp; ./mysql.server start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_mysql</span><br><span class="line">log_output <span class="string">&quot;命令行输入mysql -uroot -A 实现登录数据库&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><p><img src="/post/Shell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E4%BA%8C%E8%BF%9B%E5%88%B6MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220414095455346.png" alt="image-20220414095455346"></p>
<p><img src="/post/Shell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E4%BA%8C%E8%BF%9B%E5%88%B6MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220414095719427.png" alt="image-20220414095719427"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="修改主机参数配置"><a href="#修改主机参数配置" class="headerlink" title="修改主机参数配置"></a>修改主机参数配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">echo &quot;net.ipv4.tcp_timestamps=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_tw_recycle=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_tw_reuse=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;vm.min_free_kbytes=1024000&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_timestamps=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_tw_recycle=1&quot; &gt;&gt; /etc/sysctl.conf </span><br><span class="line">echo &quot;net.ipv4.tcp_tw_reuse=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;vm.min_free_kbytes=1024000&quot; &gt;&gt; /etc/sysctl.conf </span><br><span class="line">echo &quot;net.ipv4.tcp_timestamps=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_tw_recycle=1&quot; &gt;&gt; /etc/sysctl.conf </span><br><span class="line">echo &quot;net.ipv4.tcp_tw_reuse=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;vm.min_free_kbytes=1024000&quot; &gt;&gt; /etc/sysctl.conf </span><br><span class="line">echo &quot;net.core.somaxconn = 3000&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.core.netdev_max_backlog = 65535&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_max_syn_backlog = 65535&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_fin_timeout = 10&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.core.wmem_max = 16777216&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.core.rmem_max = 16777216&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_keepalive_time = 120&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_keepalive_intvl = 30&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_keepalive_probes = 3&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;vm.swappiness = 0&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">* hard   nproc    65535</span><br><span class="line">* soft   nproc    65535</span><br><span class="line">* hard   nofile   65535</span><br><span class="line">* soft   nofile   65535</span><br><span class="line">* hard   stack    20240</span><br><span class="line">* soft   stack    10240</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL 安装</tag>
        <tag>Shell 脚本</tag>
      </tags>
  </entry>
</search>
